'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var infernoShared = require('inferno-shared');
var classNames = _interopDefault(require('classnames'));
var infernoCreateElement = require('inferno-create-element');
var isobject = _interopDefault(require('lodash.isobject'));
var inferno = require('inferno');
var infernoPopper = require('inferno-popper');
var toNumber = _interopDefault(require('lodash.tonumber'));
var infernoAnimation = require('inferno-animation');

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function getScrollbarWidth() {
  var scrollDiv = document.createElement('div'); // .modal-scrollbar-measure styles // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.4/scss/_modal.scss#L106-L113

  scrollDiv.style.position = 'absolute';
  scrollDiv.style.top = '-9999px';
  scrollDiv.style.width = '50px';
  scrollDiv.style.height = '50px';
  scrollDiv.style.overflow = 'scroll';
  document.body.appendChild(scrollDiv);
  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
}
function setScrollbarWidth(padding) {
  document.body.style.paddingRight = padding > 0 ? "".concat(padding, "px") : null;
}
function isBodyOverflowing() {
  return document.body.clientWidth < window.innerWidth;
}
function getOriginalBodyPadding() {
  return parseInt(window.getComputedStyle(document.body, null).getPropertyValue('padding-right') || 0, 10);
}
function conditionallyUpdateScrollbar() {
  var scrollbarWidth = getScrollbarWidth(); // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.4/js/src/modal#L420

  var fixedContent = document.querySelectorAll('.navbar-fixed-top, .navbar-fixed-bottom, .is-fixed')[0];
  var bodyPadding = fixedContent ? parseInt(fixedContent.style.paddingRight || 0, 10) : 0;

  if (isBodyOverflowing()) {
    setScrollbarWidth(bodyPadding + scrollbarWidth);
  }
}
function mapToCssModules(className, cssModule) {
  if (!cssModule) return className;
  return className.split(' ').map(function (c) {
    return cssModule[c] || c;
  }).join(' ');
}
/**
 * Returns a new object with the key/value pairs from `obj` that are not in the array `omitKeys`.
 */

function omit(obj, omitKeys) {
  var result = {};
  Object.keys(obj).forEach(function (key) {
    if (omitKeys.indexOf(key) === -1) {
      result[key] = obj[key];
    }
  });
  return result;
}
function getTarget(target) {
  if (infernoShared.isFunction(target)) {
    return target();
  }

  if (typeof target === 'string' && document) {
    var selection = document.querySelector(target);

    if (selection === null) {
      return document.querySelector("#".concat(target));
    }

    return selection;
  }

  return target;
}
var keyCodes = {
  esc: 27,
  space: 32,
  tab: 9,
  up: 38,
  down: 40
};

var utils = /*#__PURE__*/Object.freeze({
  getScrollbarWidth: getScrollbarWidth,
  setScrollbarWidth: setScrollbarWidth,
  isBodyOverflowing: isBodyOverflowing,
  getOriginalBodyPadding: getOriginalBodyPadding,
  conditionallyUpdateScrollbar: conditionallyUpdateScrollbar,
  mapToCssModules: mapToCssModules,
  omit: omit,
  getTarget: getTarget,
  keyCodes: keyCodes
});

var defaultProps = {
  tag: 'div'
};

var Container = function Container(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      fluid = props.fluid,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "fluid", "tag"]);

  var classes = mapToCssModules(classNames(className, fluid ? 'container-fluid' : 'container'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Container.defaultProps = defaultProps;

var defaultProps$1 = {
  tag: 'div'
};

var Row = function Row(props) {
  var children = props.children,
      className = props.className,
      col = props.col,
      cssModule = props.cssModule,
      noGutters = props.noGutters,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "col", "cssModule", "noGutters", "tag"]);

  var classes = mapToCssModules(classNames(col ? 'col mr-0' : null, className, noGutters ? 'no-gutters' : null, 'row'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Row.defaultProps = defaultProps$1;

var colWidths = ['xs', 'sm', 'md', 'lg', 'xl'];
var defaultProps$2 = {
  tag: 'div',
  widths: colWidths
};

var getColumnSizeClass = function getColumnSizeClass(isXs, colWidth, colSize) {
  if (colSize === true || colSize === '') {
    return isXs ? 'col' : "col-".concat(colWidth);
  } else if (colSize === 'auto') {
    return isXs ? 'col-auto' : "col-".concat(colWidth, "-auto");
  }

  return isXs ? "col-".concat(colSize) : "col-".concat(colWidth, "-").concat(colSize);
};

var Col = function Col(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      widths = props.widths,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "widths", "tag"]);

  var colClasses = [];
  widths.forEach(function (colWidth, i) {
    var columnProp = props[colWidth];

    if (!i && columnProp === undefined) {
      columnProp = true;
    }

    delete attributes[colWidth];

    if (!columnProp) {
      return;
    }

    var isXs = !i;
    var colClass;

    if (isobject(columnProp)) {
      var _classNames;

      var colSizeInterfix = isXs ? '-' : "-".concat(colWidth, "-");
      colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      colClasses.push(mapToCssModules(classNames((_classNames = {}, _defineProperty(_classNames, colClass, columnProp.size || columnProp.size === ''), _defineProperty(_classNames, "push".concat(colSizeInterfix).concat(columnProp.push), columnProp.push || columnProp.push === 0), _defineProperty(_classNames, "pull".concat(colSizeInterfix).concat(columnProp.pull), columnProp.pull || columnProp.pull === 0), _defineProperty(_classNames, "offset".concat(colSizeInterfix).concat(columnProp.offset), columnProp.offset || columnProp.offset === 0), _classNames))), cssModule);
    } else {
      colClass = getColumnSizeClass(isXs, colWidth, columnProp);
      colClasses.push(colClass);
    }
  });
  var classes = mapToCssModules(classNames(className, colClasses), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Col.defaultProps = defaultProps$2;

var defaultProps$3 = {
  tag: 'ul',
  vertical: false
};

var getVerticalClass = function getVerticalClass(vertical) {
  if (vertical === false) {
    return false;
  } else if (vertical === true || vertical === 'xs') {
    return 'flex-column';
  }

  return "flex-".concat(vertical, "-column");
};

var Nav = function Nav(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      tabs = props.tabs,
      pills = props.pills,
      vertical = props.vertical,
      horizontal = props.horizontal,
      justified = props.justified,
      fill = props.fill,
      navbar = props.navbar,
      card = props.card,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tabs", "pills", "vertical", "horizontal", "justified", "fill", "navbar", "card", "tag"]);

  var classes = mapToCssModules(classNames(className, navbar ? 'navbar-nav' : 'nav', horizontal ? "justify-content-".concat(horizontal) : false, getVerticalClass(vertical), {
    'nav-tabs': tabs,
    'card-header-tabs': card && tabs,
    'nav-pills': pills,
    'card-header-pills': card && pills,
    'nav-justified': justified,
    'nav-fill': fill
  }), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Nav.defaultProps = defaultProps$3;

var defaultProps$4 = {
  tag: 'nav',
  toggleable: false,
  expandable: false
};

var getToggleableClass = function getToggleableClass(toggleable) {
  if (toggleable === false) {
    return false;
  } else if (toggleable === true || toggleable === 'xs') {
    return 'navbar-expand';
  }

  return "navbar-expand-".concat(toggleable);
};

var Navbar = function Navbar(props) {
  var _classNames;

  var children = props.children,
      toggleable = props.toggleable,
      expandable = props.expandable,
      className = props.className,
      cssModule = props.cssModule,
      light = props.light,
      dark = props.dark,
      inverse = props.inverse,
      fixed = props.fixed,
      sticky = props.sticky,
      color = props.color,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "toggleable", "expandable", "className", "cssModule", "light", "dark", "inverse", "fixed", "sticky", "color", "tag"]);

  var classes = mapToCssModules(classNames(className, 'navbar', getToggleableClass(toggleable || expandable), (_classNames = {
    'navbar-light': light,
    'navbar-dark': inverse || dark
  }, _defineProperty(_classNames, "bg-".concat(color), color), _defineProperty(_classNames, "fixed-".concat(fixed), fixed), _defineProperty(_classNames, "sticky-".concat(sticky), sticky), _classNames)), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Navbar.defaultProps = defaultProps$4;

var defaultProps$5 = {
  tag: 'a'
};

var NavbarBrand = function NavbarBrand(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'navbar-brand'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

NavbarBrand.defaultProps = defaultProps$5;

var defaultProps$6 = {
  tag: 'button',
  type: 'button'
};

var NavbarToggler = function NavbarToggler(props) {
  var className = props.className,
      cssModule = props.cssModule,
      children = props.children,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["className", "cssModule", "children", "tag"]);

  var classes = mapToCssModules(classNames(className, 'navbar-toggler'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children || inferno.createVNode(1, "span", mapToCssModules('navbar-toggler-icon', cssModule)));
};

NavbarToggler.defaultProps = defaultProps$6;

function findDOMNode(ref) {
  if (ref && ref.nodeType) {
    return ref;
  }

  if (!ref || ref.$UN) {
    return null;
  }

  if (ref.$LI) {
    return inferno.findDOMfromVNode(ref.$LI, true);
  }

  if (ref.flags) {
    return inferno.findDOMfromVNode(ref, true);
  }

  return null;
}

var defaultProps$7 = {
  isOpen: false,
  dropup: false,
  nav: false,
  addonType: false,
  inNavbar: false
};

var Dropdown =
/*#__PURE__*/
function (_Component) {
  _inherits(Dropdown, _Component);

  function Dropdown(props) {
    var _this;

    _classCallCheck(this, Dropdown);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Dropdown).call(this, props));
    _this.addEvents = _this.addEvents.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleKeyDown = _this.handleKeyDown.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.removeEvents = _this.removeEvents.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.toggle = _this.toggle.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(Dropdown, [{
    key: "getChildContext",
    value: function getChildContext() {
      return {
        toggle: this.props.toggle,
        isOpen: this.props.isOpen,
        dropup: this.props.dropup,
        inNavbar: this.props.inNavbar
      };
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.handleProps();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.isOpen !== prevProps.isOpen) {
        this.handleProps();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeEvents();
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      return findDOMNode(this);
    }
  }, {
    key: "addEvents",
    value: function addEvents() {
      var _this2 = this;

      ['click', 'touchstart', 'keyup'].forEach(function (event) {
        return document.addEventListener(event, _this2.handleDocumentClick, true);
      });
    }
  }, {
    key: "removeEvents",
    value: function removeEvents() {
      var _this3 = this;

      ['click', 'touchstart', 'keyup'].forEach(function (event) {
        return document.removeEventListener(event, _this3.handleDocumentClick, true);
      });
    }
  }, {
    key: "handleDocumentClick",
    value: function handleDocumentClick(e) {
      if (e && (e.which === 3 || e.type === 'keyup' && e.which !== keyCodes.tab)) return;
      var container = this.getContainer();

      if (container.contains(e.target) && container !== e.target && (e.type !== 'keyup' || e.which === keyCodes.tab)) {
        return;
      }

      this.toggle(e);
    }
  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(e) {
      if ([keyCodes.esc, keyCodes.up, keyCodes.down, keyCodes.space].indexOf(e.which) === -1 || /button/i.test(e.target.tagName) && e.which === keyCodes.space || /input|textarea/i.test(e.target.tagName)) {
        return;
      }

      e.preventDefault();
      if (this.props.disabled) return;
      var container = this.getContainer();

      if (e.which === keyCodes.space && this.props.isOpen && container !== e.target) {
        e.target.click();
      }

      if (e.which === keyCodes.esc || !this.props.isOpen) {
        this.toggle(e);
        container.querySelector('[aria-expanded]').focus();
        return;
      }

      var menuClass = mapToCssModules('dropdown-menu', this.props.cssModule);
      var itemClass = mapToCssModules('dropdown-item', this.props.cssModule);
      var disabledClass = mapToCssModules('disabled', this.props.cssModule);
      var items = container.querySelectorAll(".".concat(menuClass, " .").concat(itemClass, ":not(.").concat(disabledClass, ")"));
      if (!items.length) return;
      var index = -1;

      for (var i = 0; i < items.length; i += 1) {
        if (items[i] === e.target) {
          index = i;
          break;
        }
      }

      if (e.which === keyCodes.up && index > 0) {
        index -= 1;
      }

      if (e.which === keyCodes.down && index < items.length - 1) {
        index += 1;
      }

      if (index < 0) {
        index = 0;
      }

      items[index].focus();
    }
  }, {
    key: "handleProps",
    value: function handleProps() {
      if (this.props.isOpen) {
        this.addEvents();
      } else {
        this.removeEvents();
      }
    }
  }, {
    key: "toggle",
    value: function toggle(e) {
      if (this.props.disabled) {
        return e && e.preventDefault();
      }

      return this.props.toggle(e);
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames;

      var _omit = omit(this.props, ['toggle', 'disabled', 'inNavbar']),
          className = _omit.className,
          cssModule = _omit.cssModule,
          dropup = _omit.dropup,
          isOpen = _omit.isOpen,
          group = _omit.group,
          size = _omit.size,
          nav = _omit.nav,
          addonType = _omit.addonType,
          attrs = _objectWithoutProperties(_omit, ["className", "cssModule", "dropup", "isOpen", "group", "size", "nav", "addonType"]);

      attrs.tag = attrs.tag || (nav ? 'li' : 'div');
      var classes = mapToCssModules(classNames(className, (_classNames = {}, _defineProperty(_classNames, "input-group-".concat(addonType), addonType), _defineProperty(_classNames, 'btn-group', group), _defineProperty(_classNames, "btn-group-".concat(size), !!size), _defineProperty(_classNames, "dropdown", !group && !addonType), _defineProperty(_classNames, "show", isOpen), _defineProperty(_classNames, "dropup", dropup), _defineProperty(_classNames, 'nav-item', nav), _classNames)), cssModule);
      return inferno.normalizeProps(inferno.createComponentVNode(2, infernoPopper.Manager, _objectSpread({}, attrs, {
        "className": classes,
        "onKeyDown": this.handleKeyDown
      })));
    }
  }]);

  return Dropdown;
}(inferno.Component);

Dropdown.defaultProps = defaultProps$7;

var defaultProps$8 = {
  tag: 'li'
};

var NavDropdown = function NavDropdown(props) {
  var className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'nav-item'), cssModule);
  return inferno.normalizeProps(inferno.createComponentVNode(2, Dropdown, _objectSpread({}, attributes, {
    "tag": Tag,
    "className": classes
  })));
};

NavDropdown.defaultProps = defaultProps$8;

var defaultProps$9 = {
  tag: 'li'
};

var NavItem = function NavItem(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'nav-item'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

NavItem.defaultProps = defaultProps$9;

var defaultProps$a = {
  tag: 'a'
};

var NavLink =
/*#__PURE__*/
function (_Component) {
  _inherits(NavLink, _Component);

  function NavLink(props) {
    var _this;

    _classCallCheck(this, NavLink);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(NavLink).call(this, props));
    _this.onClick = _this.onClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(NavLink, [{
    key: "onClick",
    value: function onClick(e) {
      if (this.props.disabled) {
        e.preventDefault();
        return;
      }

      if (this.props.href === '#') {
        e.preventDefault();
      }

      if (this.props.onClick) {
        this.props.onClick(e);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          children = _this$props.children,
          className = _this$props.className,
          cssModule = _this$props.cssModule,
          active = _this$props.active,
          Tag = _this$props.tag,
          innerRef = _this$props.innerRef,
          attributes = _objectWithoutProperties(_this$props, ["children", "className", "cssModule", "active", "tag", "innerRef"]);

      var classes = mapToCssModules(classNames(className, 'nav-link', {
        disabled: attributes.disabled,
        active: active
      }), cssModule);
      Object.assign(attributes, {
        className: classes,
        ref: innerRef,
        onClick: this.onClick
      });
      return infernoCreateElement.createElement(Tag, attributes, children);
    }
  }]);

  return NavLink;
}(inferno.Component);

NavLink.defaultProps = defaultProps$a;

var defaultProps$b = {
  tag: 'ol'
};

var Breadcrumb = function Breadcrumb(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'breadcrumb'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Breadcrumb.defaultProps = defaultProps$b;

var defaultProps$c = {
  tag: 'li'
};

var BreadcrumbItem = function BreadcrumbItem(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      active = props.active,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "active", "tag"]);

  var classes = mapToCssModules(classNames(className, active ? 'active' : false, 'breadcrumb-item'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

BreadcrumbItem.defaultProps = defaultProps$c;

var defaultProps$d = {
  color: 'secondary',
  tag: 'button'
};

var Button =
/*#__PURE__*/
function (_Component) {
  _inherits(Button, _Component);

  function Button(props) {
    var _this;

    _classCallCheck(this, Button);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Button).call(this, props));
    _this.onClick = _this.onClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(Button, [{
    key: "onClick",
    value: function onClick(e) {
      if (this.props.disabled) {
        e.preventDefault();
        return;
      }

      if (this.props.onClick) {
        this.props.onClick(e);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          active = _this$props.active,
          block = _this$props.block,
          children = _this$props.children,
          className = _this$props.className,
          cssModule = _this$props.cssModule,
          color = _this$props.color,
          outline = _this$props.outline,
          size = _this$props.size,
          Tag = _this$props.tag,
          innerRef = _this$props.innerRef,
          attributes = _objectWithoutProperties(_this$props, ["active", "block", "children", "className", "cssModule", "color", "outline", "size", "tag", "innerRef"]);

      var classes = mapToCssModules(classNames(className, 'btn', "btn".concat(outline ? '-outline' : '', "-").concat(color), size ? "btn-".concat(size) : false, block ? 'btn-block' : false, {
        active: active,
        disabled: this.props.disabled
      }), cssModule);

      if (attributes.href && Tag === 'button') {
        Tag = 'a';
      }

      Object.assign(attributes, {
        className: classes,
        type: Tag === 'button' && attributes.onClick ? 'button' : undefined,
        ref: innerRef,
        onClick: this.onClick
      });
      return infernoCreateElement.createElement(Tag, attributes, children);
    }
  }]);

  return Button;
}(inferno.Component);

Button.defaultProps = defaultProps$d;

var ButtonDropdown = function ButtonDropdown(props) {
  return inferno.normalizeProps(inferno.createComponentVNode(2, Dropdown, _objectSpread({
    "group": true
  }, props)));
};

var defaultProps$e = {
  tag: 'div',
  role: 'group'
};

var ButtonGroup = function ButtonGroup(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      size = props.size,
      vertical = props.vertical,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "size", "vertical", "tag"]);

  var classes = mapToCssModules(classNames(className, size ? 'btn-group-' + size : false, vertical ? 'btn-group-vertical' : 'btn-group'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

ButtonGroup.defaultProps = defaultProps$e;

var defaultProps$f = {
  tag: 'div',
  role: 'toolbar'
};

var ButtonToolbar = function ButtonToolbar(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'btn-toolbar'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

ButtonToolbar.defaultProps = defaultProps$f;

var defaultProps$g = {
  tag: 'button',
  toggle: true
};

var DropdownItem =
/*#__PURE__*/
function (_Component) {
  _inherits(DropdownItem, _Component);

  function DropdownItem(props) {
    var _this;

    _classCallCheck(this, DropdownItem);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropdownItem).call(this, props));
    _this.onClick = _this.onClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.getTabIndex = _this.getTabIndex.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(DropdownItem, [{
    key: "onClick",
    value: function onClick(e) {
      if (this.props.disabled || this.props.header || this.props.divider) {
        e.preventDefault();
        return;
      }

      if (this.props.onClick) {
        this.props.onClick(e);
      }

      if (this.props.toggle) {
        this.context.toggle();
      }
    }
  }, {
    key: "getTabIndex",
    value: function getTabIndex() {
      if (this.props.disabled || this.props.header || this.props.divider) {
        return '-1';
      }

      return '0';
    }
  }, {
    key: "render",
    value: function render() {
      var tabIndex = this.getTabIndex();

      var _omit = omit(this.props, ['toggle']),
          children = _omit.children,
          className = _omit.className,
          cssModule = _omit.cssModule,
          divider = _omit.divider,
          Tag = _omit.tag,
          header = _omit.header,
          active = _omit.active,
          props = _objectWithoutProperties(_omit, ["children", "className", "cssModule", "divider", "tag", "header", "active"]);

      var classes = mapToCssModules(classNames(className, {
        disabled: props.disabled,
        'dropdown-item': !divider && !header,
        active: active,
        'dropdown-header': header,
        'dropdown-divider': divider
      }), cssModule);

      if (Tag === 'button') {
        if (header) {
          Tag = 'h6';
        } else if (divider) {
          Tag = 'div';
        } else if (props.href) {
          Tag = 'a';
        }
      }

      Object.assign(props, {
        className: classes,
        tabIndex: tabIndex,
        type: Tag === 'button' && (props.onClick || this.props.toggle) ? 'button' : undefined,
        onClick: this.onClick
      });
      return infernoCreateElement.createElement(Tag, props, children);
    }
  }]);

  return DropdownItem;
}(inferno.Component);

DropdownItem.defaultProps = defaultProps$g;

var defaultProps$h = {
  tag: 'div',
  flip: true
};
var noFlipModifier = {
  flip: {
    enabled: false
  }
};

var DropdownMenu = function DropdownMenu(props, context) {
  var className = props.className,
      cssModule = props.cssModule,
      right = props.right,
      tag = props.tag,
      flip = props.flip,
      attrs = _objectWithoutProperties(props, ["className", "cssModule", "right", "tag", "flip"]);

  var position1 = context.dropup ? 'top' : 'bottom';
  var position2 = right ? 'end' : 'start';
  var classes = mapToCssModules(classNames(className, 'dropdown-menu', {
    'dropdown-menu-right': right,
    show: context.isOpen
  }), cssModule);
  attrs.placement = "".concat(position1, "-").concat(position2);
  return inferno.normalizeProps(inferno.createComponentVNode(2, infernoPopper.Popper, _objectSpread({
    "tabIndex": "-1",
    "role": "menu"
  }, attrs, {
    "component": tag,
    "aria-hidden": !context.isOpen,
    "className": classes,
    "modifiers": !flip ? noFlipModifier : undefined
  })));
};

DropdownMenu.defaultProps = defaultProps$h;

var defaultProps$i = {
  'data-toggle': 'dropdown',
  'aria-haspopup': true,
  color: 'secondary'
};

var DropdownToggle =
/*#__PURE__*/
function (_Component) {
  _inherits(DropdownToggle, _Component);

  function DropdownToggle(props) {
    var _this;

    _classCallCheck(this, DropdownToggle);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropdownToggle).call(this, props));
    _this.onClick = _this.onClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(DropdownToggle, [{
    key: "onClick",
    value: function onClick(e) {
      if (this.props.disabled) {
        e.preventDefault();
        return;
      }

      if (this.props.nav && !this.props.tag) {
        e.preventDefault();
      }

      if (this.props.onClick) {
        this.props.onClick(e);
      }

      this.context.toggle(e);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          className = _this$props.className,
          color = _this$props.color,
          cssModule = _this$props.cssModule,
          caret = _this$props.caret,
          split = _this$props.split,
          nav = _this$props.nav,
          tag = _this$props.tag,
          props = _objectWithoutProperties(_this$props, ["className", "color", "cssModule", "caret", "split", "nav", "tag"]);

      var ariaLabel = props['aria-label'] || 'Toggle Dropdown';
      var classes = mapToCssModules(classNames(className, {
        'dropdown-toggle': caret || split,
        'dropdown-toggle-split': split,
        'nav-link': nav
      }), cssModule);
      var children = props.children || inferno.createVNode(1, "span", "sr-only", ariaLabel, 0);
      var Tag;

      if (nav && !tag) {
        Tag = 'a';
        props.href = '#';
      } else if (!tag) {
        Tag = Button;
        props.color = color;
        props.cssModule = cssModule;
      } else {
        Tag = tag;
      }

      return inferno.normalizeProps(inferno.createComponentVNode(2, infernoPopper.Target, _objectSpread({}, props, {
        "className": classes,
        "component": Tag,
        "onClick": this.onClick,
        "aria-haspopup": "true",
        "aria-expanded": this.context.isOpen,
        "children": children
      })));
    }
  }]);

  return DropdownToggle;
}(inferno.Component);

DropdownToggle.defaultProps = defaultProps$i;

var defaultProps$j = {
  color: 'secondary',
  pill: false,
  tag: 'span'
};

var Badge = function Badge(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      color = props.color,
      pill = props.pill,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "color", "pill", "tag"]);

  var classes = mapToCssModules(classNames(className, 'badge', 'badge-' + color, pill ? 'badge-pill' : false), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Badge.defaultProps = defaultProps$j;

var defaultProps$k = {
  tag: 'div'
};

var Card = function Card(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      color = props.color,
      block = props.block,
      body = props.body,
      inverse = props.inverse,
      outline = props.outline,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "color", "block", "body", "inverse", "outline", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card', inverse ? 'text-white' : false, block || body ? 'card-body' : false, color ? "".concat(outline ? 'border' : 'bg', "-").concat(color) : false), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Card.defaultProps = defaultProps$k;

var defaultProps$l = {
  tag: 'div'
};

var CardBody = function CardBody(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card-body'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardBody.defaultProps = defaultProps$l;

var defaultProps$m = {
  tag: 'div'
};

var CardColumns = function CardColumns(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card-columns'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardColumns.defaultProps = defaultProps$m;

var defaultProps$n = {
  tag: 'div'
};

var CardDeck = function CardDeck(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card-deck'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardDeck.defaultProps = defaultProps$n;

var defaultProps$o = {
  tag: 'div'
};

var CardFooter = function CardFooter(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card-footer'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardFooter.defaultProps = defaultProps$o;

var defaultProps$p = {
  tag: 'div'
};

var CardGroup = function CardGroup(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card-group'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardGroup.defaultProps = defaultProps$p;

var defaultProps$q = {
  tag: 'div'
};

var CardHeader = function CardHeader(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card-header'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardHeader.defaultProps = defaultProps$q;

var defaultProps$r = {
  tag: 'img'
};

var CardImg = function CardImg(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      top = props.top,
      bottom = props.bottom,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "top", "bottom", "tag"]);

  var cardImgClassName = 'card-img';

  if (top) {
    cardImgClassName = 'card-img-top';
  }

  if (bottom) {
    cardImgClassName = 'card-img-bottom';
  }

  var classes = mapToCssModules(classNames(className, cardImgClassName), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardImg.defaultProps = defaultProps$r;

var defaultProps$s = {
  tag: 'div'
};

var CardImgOverlay = function CardImgOverlay(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card-img-overlay'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardImgOverlay.defaultProps = defaultProps$s;

var defaultProps$t = {
  tag: 'a'
};

var CardLink = function CardLink(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      innerRef = props.innerRef,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag", "innerRef"]);

  var classes = mapToCssModules(classNames(className, 'card-link'), cssModule);
  Object.assign(attributes, {
    className: classes,
    ref: innerRef
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardLink.defaultProps = defaultProps$t;

var defaultProps$u = {
  tag: 'h6'
};

var CardSubtitle = function CardSubtitle(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card-subtitle'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardSubtitle.defaultProps = defaultProps$u;

var defaultProps$v = {
  tag: 'p'
};

var CardText = function CardText(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card-text'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardText.defaultProps = defaultProps$v;

var defaultProps$w = {
  tag: 'h4'
};

var CardTitle = function CardTitle(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'card-title'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

CardTitle.defaultProps = defaultProps$w;

var defaultProps$x = {
  tag: 'form'
};
/**
 * 
 * NOTE: I have removed the `inline`-attribute, this can be done with CSS
 * which gives cleaner code and better separation of semantics and styling.
 */

var Form = function Form(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      innerRef = props.innerRef,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag", "innerRef"]);

  var classes = mapToCssModules(classNames(className), cssModule);
  Object.assign(attributes, {
    className: classes,
    ref: innerRef
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Form.defaultProps = defaultProps$x;

var defaultProps$y = {
  tag: 'div'
};

var FormFeedback = function FormFeedback(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'invalid-feedback'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

FormFeedback.defaultProps = defaultProps$y;

var defaultProps$z = {
  tag: 'div'
};

var FormGroup = function FormGroup(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      row = props.row,
      disabled = props.disabled,
      check = props.check,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "row", "disabled", "check", "tag"]);

  var classes = mapToCssModules(classNames(className, row ? 'row' : false, check ? 'form-check' : 'form-group', check && disabled ? 'disabled' : false), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

FormGroup.defaultProps = defaultProps$z;

var defaultProps$A = {
  tag: 'small'
};

var FormText = function FormText(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      inline = props.inline,
      color = props.color,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "inline", "color", "tag"]);

  var classes = mapToCssModules(classNames(className, !inline ? 'form-text' : false, color ? "text-".concat(color) : typeof color === 'undefined' && 'text-muted'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

FormText.defaultProps = defaultProps$A;

var defaultProps$B = {
  tag: 'p',
  type: 'text'
};

var Input =
/*#__PURE__*/
function (_Component) {
  _inherits(Input, _Component);

  function Input() {
    _classCallCheck(this, Input);

    return _possibleConstructorReturn(this, _getPrototypeOf(Input).apply(this, arguments));
  }

  _createClass(Input, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          className = _this$props.className,
          cssModule = _this$props.cssModule,
          type = _this$props.type,
          bsSize = _this$props.bsSize,
          tag = _this$props.tag,
          valid = _this$props.valid,
          addon = _this$props.addon,
          plaintext = _this$props.plaintext,
          innerRef = _this$props.innerRef,
          attributes = _objectWithoutProperties(_this$props, ["className", "cssModule", "type", "bsSize", "tag", "valid", "addon", "plaintext", "innerRef"]);

      var checkInput = ['radio', 'checkbox'].indexOf(type) > -1;
      var fileInput = type === 'file';
      var textareaInput = type === 'textarea';
      var selectInput = type === 'select';
      var Tag = selectInput || textareaInput ? type : 'input';
      var formControlClass = 'form-control';

      if (plaintext) {
        formControlClass = "".concat(formControlClass, "-plaintext");
        Tag = tag;
      } else if (fileInput) {
        formControlClass = "".concat(formControlClass, "-file");
      } else if (checkInput) {
        if (addon) {
          formControlClass = null;
        } else {
          formControlClass = 'form-check-input';
        }
      }

      var classes = mapToCssModules(classNames(className, valid === false && 'is-invalid', valid && 'is-valid', bsSize ? "form-control-".concat(bsSize) : false, formControlClass), cssModule);

      if (Tag === 'input') {
        attributes.type = type;
      }

      Object.assign(attributes, {
        className: classes,
        ref: innerRef
      });
      return infernoCreateElement.createElement(Tag, attributes);
    }
  }]);

  return Input;
}(inferno.Component);

Input.defaultProps = defaultProps$B;

var defaultProps$C = {
  tag: 'div'
};

var InputGroup = function InputGroup(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      size = props.size,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag", "size"]);

  var classes = mapToCssModules(classNames(className, 'input-group', size ? "input-group-".concat(size) : null), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

InputGroup.defaultProps = defaultProps$C;

var defaultProps$D = {
  tag: 'span'
};

var InputGroupText = function InputGroupText(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'input-group-text'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

InputGroupText.defaultProps = defaultProps$D;

var defaultProps$E = {
  tag: 'div'
};

var InputGroupAddon = function InputGroupAddon(props) {
  var className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      addonType = props.addonType,
      children = props.children,
      attributes = _objectWithoutProperties(props, ["className", "cssModule", "tag", "addonType", "children"]);

  var classes = mapToCssModules(classNames(className, 'input-group-' + addonType), cssModule); // Convenience to assist with transition

  if (typeof children === 'string') {
    Object.assign(attributes, {
      className: classes
    });
    return infernoCreateElement.createElement(Tag, attributes, inferno.createComponentVNode(2, InputGroupText, {
      children: children
    }));
  }

  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

InputGroupAddon.defaultProps = defaultProps$E;

var defaultProps$F = {
  tag: 'div'
};

var InputGroupButton = function InputGroupButton(props) {
  var className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      addonType = props.addonType,
      children = props.children,
      groupClassName = props.groupClassName,
      groupAttributes = props.groupAttributes,
      attributes = _objectWithoutProperties(props, ["className", "cssModule", "tag", "addonType", "children", "groupClassName", "groupAttributes"]);

  if (typeof children === 'string') {
    var groupClasses = mapToCssModules(classNames(groupClassName, 'input-group-' + addonType), cssModule);
    groupAttributes = groupAttributes || {};
    Object.assign(groupAttributes, {
      className: groupClasses
    });
    return infernoCreateElement.createElement(Tag, groupAttributes, inferno.normalizeProps(inferno.createComponentVNode(2, Button, _objectSpread({}, attributes, {
      "className": className,
      children: children
    }))));
  }

  var classes = mapToCssModules(classNames(className, 'input-group-' + addonType), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

InputGroupButton.defaultProps = defaultProps$F;

var InputGroupButtonDropdown = function InputGroupButtonDropdown(props) {
  return inferno.normalizeProps(inferno.createComponentVNode(2, Dropdown, _objectSpread({}, props)));
};

var defaultProps$G = {
  tag: 'label'
};
/**
 * 
 * NOTE: I have removed the `inline`-attribute, this can be done with CSS
 * which gives cleaner code and better separation of semantics and styling.
 * 
 * This affects widths property
 */

var Label = function Label(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      hidden = props.hidden,
      Tag = props.tag,
      check = props.check,
      disabled = props.disabled,
      htmlFor = props.htmlFor,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "hidden", "tag", "check", "disabled", "htmlFor"]);

  var classes = mapToCssModules(classNames(className, hidden ? 'sr-only' : false, check ? 'form-check-label' : 'form-control-label', check && disabled ? 'disabled' : false), cssModule);
  Object.assign(attributes, {
    className: classes,
    htmlFor: htmlFor
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Label.defaultProps = defaultProps$G;

var PopperTargetHelper = function PopperTargetHelper(props, context) {
  context.popperManager.setTargetNode(getTarget(props.target));
  return null;
};

var defaultProps$H = {
  placement: 'auto',
  isOpen: false,
  offset: 0,
  fallbackPlacement: 'flip',
  wrapTag: 'span',
  flip: true
};

var PopperContent =
/*#__PURE__*/
function (_Component) {
  _inherits(PopperContent, _Component);

  function PopperContent(props) {
    var _this;

    _classCallCheck(this, PopperContent);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PopperContent).call(this, props));
    _this.handlePlacementChange = _this.handlePlacementChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.state = {};
    return _this;
  }

  _createClass(PopperContent, [{
    key: "handlePlacementChange",
    value: function handlePlacementChange(data) {
      if (this.state.placement !== data.placement) {
        this.setState({
          placement: data.placement
        });
      }

      return data;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          cssModule = _this$props.cssModule,
          children = _this$props.children,
          isOpen = _this$props.isOpen,
          flip = _this$props.flip,
          target = _this$props.target,
          offset = _this$props.offset,
          fallbackPlacement = _this$props.fallbackPlacement,
          placementPrefix = _this$props.placementPrefix,
          className = _this$props.className,
          wrapTag = _this$props.wrapTag,
          wrapClassName = _this$props.wrapClassName,
          tag = _this$props.tag,
          attrs = _objectWithoutProperties(_this$props, ["cssModule", "children", "isOpen", "flip", "target", "offset", "fallbackPlacement", "placementPrefix", "className", "wrapTag", "wrapClassName", "tag"]);

      var arrowClassName = mapToCssModules('arrow', cssModule);
      var placement = (this.state.placement || attrs.placement).split('-')[0];
      var managerClass = mapToCssModules(wrapClassName, this.props.cssModule);
      var popperClassName = mapToCssModules(classNames(className, placementPrefix ? "".concat(placementPrefix, "-").concat(placement) : placement), this.props.cssModule);
      var modifiers = {
        offset: {
          offset: offset
        },
        flip: {
          enabled: flip,
          behavior: fallbackPlacement
        },
        update: {
          enabled: true,
          order: 950,
          fn: this.handlePlacementChange
        }
      };
      return inferno.createComponentVNode(2, infernoPopper.Manager, {
        "tag": wrapTag,
        "className": managerClass,
        children: [inferno.createComponentVNode(2, PopperTargetHelper, {
          "target": target
        }), isOpen && inferno.normalizeProps(inferno.createComponentVNode(2, infernoPopper.Popper, _objectSpread({
          "modifiers": modifiers
        }, attrs, {
          "component": tag,
          "className": popperClassName,
          children: [children, inferno.createComponentVNode(2, infernoPopper.Arrow, {
            "className": arrowClassName
          })]
        })))]
      });
    }
  }]);

  return PopperContent;
}(inferno.Component);

PopperContent.defaultProps = defaultProps$H;

var omitProps = ['placement', 'target', 'isOpen', 'cssModule', 'className', 'delay', 'disabled', 'placementPrefix', 'toggle'];
var DEFAULT_DELAYS = {
  show: 0,
  hide: 0
};
var defaultProps$I = {
  isOpen: false,
  placement: 'right',
  placementPrefix: 'bs-popover',
  delay: DEFAULT_DELAYS,
  toggle: function toggle() {}
};

var Popover =
/*#__PURE__*/
function (_Component) {
  _inherits(Popover, _Component);

  function Popover(props) {
    var _this;

    _classCallCheck(this, Popover);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Popover).call(this, props));
    _this.addTargetEvents = _this.addTargetEvents.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.removeTargetEvents = _this.removeTargetEvents.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.toggle = _this.toggle.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.show = _this.show.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.hide = _this.hide.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(Popover, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._target = getTarget(this.props.target);
      this.handleProps();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.handleProps();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearShowTimeout();
      this.clearHideTimeout();
      this.removeTargetEvents();
    }
  }, {
    key: "getDelay",
    value: function getDelay(key) {
      var delay = this.props.delay;

      if (_typeof(delay) === 'object') {
        return !infernoShared.isNumber(delay[key]) ? DEFAULT_DELAYS[key] : delay[key];
      }

      return delay;
    }
  }, {
    key: "handleProps",
    value: function handleProps() {
      if (this.props.isOpen) {
        this.show();
      } else {
        this.hide();
      }
    }
  }, {
    key: "show",
    value: function show() {
      this.clearHideTimeout();
      this.addTargetEvents();

      if (!this.props.isOpen) {
        this.clearShowTimeout();
        this._showTimeout = setTimeout(this.toggle, this.getDelay('show'));
      }
    }
  }, {
    key: "hide",
    value: function hide() {
      this.clearShowTimeout();
      this.removeTargetEvents();

      if (this.props.isOpen) {
        this.clearHideTimeout();
        this._hideTimeout = setTimeout(this.toggle, this.getDelay('hide'));
      }
    }
  }, {
    key: "clearShowTimeout",
    value: function clearShowTimeout() {
      clearTimeout(this._showTimeout);
      this._showTimeout = undefined;
    }
  }, {
    key: "clearHideTimeout",
    value: function clearHideTimeout() {
      clearTimeout(this._hideTimeout);
      this._hideTimeout = undefined;
    }
  }, {
    key: "handleDocumentClick",
    value: function handleDocumentClick(e) {
      if (e.target !== this._target && !this._target.contains(e.target)) {
        if (this._hideTimeout) {
          this.clearHideTimeout();
        }

        if (this.props.isOpen) {
          this.toggle();
        }
      }
    }
  }, {
    key: "addTargetEvents",
    value: function addTargetEvents() {
      document.addEventListener('click', this.handleDocumentClick, true);
    }
  }, {
    key: "removeTargetEvents",
    value: function removeTargetEvents() {
      document.removeEventListener('click', this.handleDocumentClick, true);
    }
  }, {
    key: "toggle",
    value: function toggle(e) {
      if (this.props.disabled) {
        return e && e.preventDefault();
      }

      return this.props.toggle();
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.props.isOpen) {
        return null;
      }

      var attributes = omit(this.props, Object.keys(omitProps));
      var classes = mapToCssModules(classNames('popover-inner', this.props.className), this.props.cssModule);
      var popperClasses = mapToCssModules(classNames('popover', 'show'), this.props.cssModule);
      return inferno.createComponentVNode(2, PopperContent, {
        "className": popperClasses,
        "target": this.props.target,
        "isOpen": this.props.isOpen,
        "placement": this.props.placement,
        "placementPrefix": this.props.placementPrefix,
        children: inferno.normalizeProps(inferno.createVNode(1, "div", classes, null, 1, _objectSpread({}, attributes)))
      });
    }
  }]);

  return Popover;
}(inferno.Component);

Popover.defaultProps = defaultProps$I;

var defaultProps$J = {
  tag: 'div'
};

var PopoverBody = function PopoverBody(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'popover-body'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

PopoverBody.defaultProps = defaultProps$J;

var defaultProps$K = {
  tag: 'h3'
};

var PopoverHeader = function PopoverHeader(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'popover-header'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

PopoverHeader.defaultProps = defaultProps$K;

var defaultProps$L = {
  tag: 'div',
  value: 0,
  max: 100
};

var Progress = function Progress(props) {
  var children = props.children,
      className = props.className,
      barClassName = props.barClassName,
      cssModule = props.cssModule,
      value = props.value,
      max = props.max,
      animated = props.animated,
      striped = props.striped,
      color = props.color,
      bar = props.bar,
      multi = props.multi,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "barClassName", "cssModule", "value", "max", "animated", "striped", "color", "bar", "multi", "tag"]);

  var percent = toNumber(value) / toNumber(max) * 100;
  var progressClasses = mapToCssModules(classNames(className, 'progress'), cssModule);
  var progressBarClasses = mapToCssModules(classNames('progress-bar', bar ? className || barClassName : barClassName, animated ? 'progress-bar-animated' : null, color ? "bg-".concat(color) : null, striped || animated ? 'progress-bar-striped' : null), cssModule);
  var ProgressBar = multi ? children : inferno.createVNode(1, "div", progressBarClasses, children, 0, {
    "style": {
      width: "".concat(percent, "%")
    },
    "role": "progressbar",
    "aria-valuenow": value,
    "aria-valuemin": "0",
    "aria-valuemax": max
  });

  if (bar) {
    return ProgressBar;
  }

  Object.assign(attributes, {
    className: progressClasses
  });
  return infernoCreateElement.createElement(Tag, attributes, ProgressBar);
};

Progress.defaultProps = defaultProps$L;

var addClassName = infernoAnimation.utils.addClassName,
    removeClassName = infernoAnimation.utils.removeClassName,
    registerTransitionListener = infernoAnimation.utils.registerTransitionListener,
    forceReflow = infernoAnimation.utils.forceReflow,
    setDisplay = infernoAnimation.utils.setDisplay;
/**
 * These are the open and close animation helpers
 */

function animateModalOnRemove(node, callback) {
  var clone = node.cloneNode(true);
  setDisplay(node, 'none !important');
  node.parentNode.appendChild(clone);
  registerTransitionListener(clone, function () {
    // *** Cleanup ***
    callback && callback(clone);
    clone.remove();
  });
  setTimeout(function () {
    removeClassName(clone, 'show');
  }, 5);
}
function animateModalOnAdd(node, callback) {
  setDisplay(node, 'none');
  addClassName(node, 'fade');
  forceReflow(node);
  setDisplay(node, 'block');
  registerTransitionListener([node, node.children[0]], function () {
    // *** Cleanup ***
    callback && callback(node);
  });
  addClassName(node, 'show');
}
function Animated(props) {
  var Tag = props.tag,
      children = props.children,
      attrs = _objectWithoutProperties(props, ["tag", "children"]);

  return infernoCreateElement.createElement(Tag || 'div', attrs, children);
}

var propsToOmit = ['animationPrefix', 'backgroundAnimationPrefix', 'isOpen', 'autoFocus', 'size', 'toggle', 'keyboard', 'backdrop', 'onEnter', 'onExit', 'onOpened', 'onClosed', 'children', 'className', 'wrapClassName', 'modalClassName', 'backdropClassName', 'contentClassName', 'fade', 'cssModule', 'zIndex'];
var defaultProps$M = {
  isOpen: false,
  autoFocus: true,
  backdrop: true,
  keyboard: true,
  zIndex: 1050,
  fade: true
};

var Modal =
/*#__PURE__*/
function (_Component) {
  _inherits(Modal, _Component);

  function Modal(props) {
    var _this;

    _classCallCheck(this, Modal);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Modal).call(this, props));
    _this.originalBodyPadding = null;
    _this.isBodyOverflowing = false;
    _this.togglePortal = _this.togglePortal.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleBackdropClick = _this.handleBackdropClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleEscape = _this.handleEscape.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.destroy = _this.destroy.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onOpened = _this.onOpened.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onClosed = _this.onClosed.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.createEventListeners = _this.createEventListeners.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.state = {};
    return _this;
  }

  _createClass(Modal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.isOpen) {
        this.togglePortal();
      }

      if (this.props.onEnter) {
        this.props.onEnter();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.isOpen !== prevProps.isOpen) {
        // handle portal events/dom updates
        this.togglePortal();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.destroy();

      if (this.props.onExit) {
        this.props.onExit();
      }
    }
  }, {
    key: "onOpened",
    value: function onOpened() {
      if (this.props.onOpened) {
        this.props.onOpened();
      }
    }
  }, {
    key: "onClosed",
    value: function onClosed() {
      this.destroy();

      if (this.props.onClosed) {
        this.props.onClosed();
      }
    }
  }, {
    key: "handleEscape",
    value: function handleEscape(e) {
      if (this._dialog && this.props.keyboard && e.keyCode === 27 && this.props.toggle) {
        this.props.toggle();
      }
    }
  }, {
    key: "handleBackdropClick",
    value: function handleBackdropClick(e) {
      if (!this._dialog || this.props.backdrop !== true) return;
      var container = this._dialog;

      if (e.target && !container.contains(e.target) && this.props.toggle) {
        this.props.toggle();
      }
    }
  }, {
    key: "togglePortal",
    value: function togglePortal() {
      if (this.props.isOpen) {
        if (this.props.autoFocus) {
          this._focus = true;
        }

        this.show();
      } else {
        this.hide();
      }
    }
  }, {
    key: "createEventListeners",
    value: function createEventListeners() {
      window.addEventListener('keyup', this.handleEscape);
      window.addEventListener('click', this.handleBackdropClick, true);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      window.removeEventListener('keyup', this.handleEscape);
      window.removeEventListener('click', this.handleBackdropClick, true);

      if (this.state._element) {
        var _element = this.state._element;
        this.setState({
          _element: null
        });
        document.body.removeChild(_element);
      } // Use regex to prevent matching `modal-open` as part of a different class, e.g. `my-modal-opened`


      var classes = document.body.className.replace(/(^| )modal-open( |$)/, ' ');
      document.body.className = mapToCssModules(classNames(classes).trim(), this.props.cssModule);
      setScrollbarWidth(this.originalBodyPadding);
    }
  }, {
    key: "hide",
    value: function hide() {
      // Need to trigger cleanup if the animation doesn't play
      if (!this.props.fade) {
        this.destroy();
      }
    }
  }, {
    key: "show",
    value: function show() {
      var classes = document.body.className;

      var _element = document.createElement('div');

      _element.setAttribute('tabindex', '-1');

      _element.style.position = 'relative';
      _element.style.zIndex = this.props.zIndex;
      this.originalBodyPadding = getOriginalBodyPadding();
      conditionallyUpdateScrollbar();
      this.createEventListeners();
      document.body.appendChild(_element);
      document.body.className = mapToCssModules(classNames(classes, 'modal-open'), this.props.cssModule);
      this.setState({
        _element: _element
      });
    }
  }, {
    key: "renderModalDialog",
    value: function renderModalDialog() {
      var _this2 = this;

      var attributes = omit(this.props, propsToOmit);
      return inferno.normalizeProps(inferno.createVNode(1, "div", mapToCssModules(classNames('modal-dialog', this.props.className, _defineProperty({}, "modal-".concat(this.props.size), this.props.size)), this.props.cssModule), inferno.createVNode(1, "div", mapToCssModules(classNames('modal-content', this.props.contentClassName), this.props.cssModule), this.props.children, 0), 2, _objectSpread({
        "role": "document"
      }, attributes), null, function (c) {
        _this2._dialog = c;

        if (_this2._focus) {
          c.parentNode.focus();
          _this2._focus = false;
        }
      }));
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var _this$props = this.props,
          wrapClassName = _this$props.wrapClassName,
          modalClassName = _this$props.modalClassName,
          backdropClassName = _this$props.backdropClassName,
          cssModule = _this$props.cssModule,
          isOpen = _this$props.isOpen,
          backdrop = _this$props.backdrop,
          modalTransitionTimeout = _this$props.modalTransitionTimeout,
          backdropTransitionTimeout = _this$props.backdropTransitionTimeout;
      var modalAttributes = {
        tabIndex: '-1'
      };
      var prefix = this.props.animationPrefix || "ModalFade";
      var backgroundPrefix = this.props.backgroundAnimationPrefix || "ModalBackdropFade";

      if (this.props.fade) {
        return inferno.createVNode(1, "div", mapToCssModules(wrapClassName), [inferno.normalizeProps(inferno.createComponentVNode(2, AnimatedSpecial, _objectSpread({
          "isOpen": isOpen,
          "cssModule": cssModule,
          "className": mapToCssModules(classNames('modal', modalClassName), cssModule),
          "onOpened": this.onOpened,
          "onClosed": this.onClosed
        }, modalAttributes, {
          children: this.renderModalDialog()
        }), "modal-dialog")), inferno.createComponentVNode(2, AnimatedSpecial, {
          "isOpen": isOpen && backdrop,
          "cssModule": cssModule,
          "className": mapToCssModules(classNames('modal-backdrop', backdropClassName), cssModule)
        }, "modal-backdrop")], 8);
      }

      return inferno.createVNode(1, "div", mapToCssModules(wrapClassName), [isOpen && inferno.normalizeProps(inferno.createVNode(1, "div", mapToCssModules(classNames('modal', 'show', modalClassName), cssModule), this.renderModalDialog(), 0, _objectSpread({
        "style": {
          display: 'block'
        }
      }, modalAttributes))), isOpen && backdrop && inferno.createVNode(1, "div", mapToCssModules(classNames('modal-backdrop', 'show', backdropClassName), cssModule))], 0);
    }
  }, {
    key: "render",
    value: function render() {
      return this.state._element ? inferno.createPortal(this.renderChildren(), this.state._element) : null;
    }
  }]);

  return Modal;
}(inferno.Component);

Modal.defaultProps = defaultProps$M;

var AnimatedSpecial =
/*#__PURE__*/
function (_Component2) {
  _inherits(AnimatedSpecial, _Component2);

  function AnimatedSpecial() {
    _classCallCheck(this, AnimatedSpecial);

    return _possibleConstructorReturn(this, _getPrototypeOf(AnimatedSpecial).apply(this, arguments));
  }

  _createClass(AnimatedSpecial, [{
    key: "render",

    /*
    I need to create a separate component to get unmount to work properly
    since animations are triggered on unmount and I don't want inferno to
    remove all the elements until the animation is completed.
     */
    value: function render(_ref) {
      var isOpen = _ref.isOpen,
          onClosed = _ref.onClosed,
          onOpened = _ref.onOpened,
          attrs = _objectWithoutProperties(_ref, ["isOpen", "onClosed", "onOpened"]);

      if (isOpen) {
        return inferno.normalizeProps(inferno.createComponentVNode(2, Animated, _objectSpread({}, attrs), null, {
          "onComponentDidMount": function onComponentDidMount(dom) {
            return animateModalOnAdd(dom, onOpened);
          },
          "onComponentWillUnmount": function onComponentWillUnmount(dom) {
            return animateModalOnRemove(dom, onClosed);
          }
        }));
      } else {
        return null;
      }
    }
  }]);

  return AnimatedSpecial;
}(inferno.Component);
/*
  props.bootstrapCls = {
    hide: ,
    active: 'modal fade',
    show: 'modal show'
  }
*/

var defaultProps$N = {
  tag: 'h4',
  wrapTag: 'div',
  closeAriaLabel: 'Close'
};

var ModalHeader = function ModalHeader(props) {
  var closeButton;

  var className = props.className,
      cssModule = props.cssModule,
      children = props.children,
      toggle = props.toggle,
      Tag = props.tag,
      WrapTag = props.wrapTag,
      closeAriaLabel = props.closeAriaLabel,
      attributes = _objectWithoutProperties(props, ["className", "cssModule", "children", "toggle", "tag", "wrapTag", "closeAriaLabel"]);

  var classes = mapToCssModules(classNames(className, 'modal-header'), cssModule);

  if (toggle) {
    closeButton = inferno.createVNode(1, "button", "close", inferno.createVNode(1, "span", null, String.fromCharCode(215), 0, {
      "aria-hidden": "true"
    }), 2, {
      "type": "button",
      "onClick": toggle,
      "aria-label": closeAriaLabel
    });
  }

  var innerChildren = [infernoCreateElement.createElement(Tag, {
    className: mapToCssModules('modal-title', cssModule)
  }, children), closeButton];
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(WrapTag, attributes, innerChildren);
};

ModalHeader.defaultProps = defaultProps$N;

var defaultProps$O = {
  tag: 'div'
};

var ModalBody = function ModalBody(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'modal-body'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

ModalBody.defaultProps = defaultProps$O;

var defaultProps$P = {
  tag: 'div'
};

var ModalFooter = function ModalFooter(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var classes = mapToCssModules(classNames(className, 'modal-footer'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

ModalFooter.defaultProps = defaultProps$P;

var defaultProps$Q = {
  tag: 'table',
  responsiveTag: 'div'
};

var Table = function Table(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      size = props.size,
      bordered = props.bordered,
      striped = props.striped,
      inverse = props.inverse,
      dark = props.dark,
      hover = props.hover,
      responsive = props.responsive,
      Tag = props.tag,
      ResponsiveTag = props.responsiveTag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "size", "bordered", "striped", "inverse", "dark", "hover", "responsive", "tag", "responsiveTag"]);

  var classes = mapToCssModules(classNames(className, 'table', size ? 'table-' + size : false, bordered ? 'table-bordered' : false, striped ? 'table-striped' : false, dark || inverse ? 'table-dark' : false, hover ? 'table-hover' : false), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  var table = infernoCreateElement.createElement(Tag, attributes, children);

  if (responsive) {
    var responsiveClassName = responsive === true ? 'table-responsive' : "table-responsive-".concat(responsive);
    return infernoCreateElement.createElement(ResponsiveTag, {
      className: responsiveClassName
    }, table);
  }

  return table;
};

Table.defaultProps = defaultProps$Q;

var defaultProps$R = {
  tag: 'ul'
};

var Pagination = function Pagination(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      size = props.size,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "size", "tag"]);

  var classes = mapToCssModules(classNames(className, 'pagination', _defineProperty({}, "pagination-".concat(size), !!size)), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Pagination.defaultProps = defaultProps$R;

var defaultProps$S = {
  tag: 'li'
};

var PaginationItem = function PaginationItem(props) {
  var active = props.active,
      children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      disabled = props.disabled,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["active", "children", "className", "cssModule", "disabled", "tag"]);

  var classes = mapToCssModules(classNames(className, 'page-item', {
    active: active,
    disabled: disabled
  }), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

PaginationItem.defaultProps = defaultProps$S;

var defaultProps$T = {
  tag: 'a'
};

var PaginationLink = function PaginationLink(props) {
  var className = props.className,
      cssModule = props.cssModule,
      next = props.next,
      previous = props.previous,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["className", "cssModule", "next", "previous", "tag"]);

  var classes = mapToCssModules(classNames(className, 'page-link'), cssModule);
  var defaultAriaLabel;

  if (previous) {
    defaultAriaLabel = 'Previous';
  } else if (next) {
    defaultAriaLabel = 'Next';
  }

  var ariaLabel = props['aria-label'] || defaultAriaLabel;
  var defaultCaret;

  if (previous) {
    defaultCaret = "\xAB";
  } else if (next) {
    defaultCaret = "\xBB";
  }

  var children = props.children;

  if (previous || next) {
    children = [inferno.createVNode(1, "span", null, children || defaultCaret, 0, {
      "aria-hidden": "true"
    }, "caret"), inferno.createVNode(1, "span", "sr-only", ariaLabel, 0, null, "sr")];
  }

  Object.assign(attributes, {
    'aria-label': ariaLabel,
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

PaginationLink.defaultProps = defaultProps$T;

var defaultProps$U = {
  tag: 'div'
};
var omitProps$1 = ['tag', 'activeTab', 'className', 'cssModule'];

function getContentSize() {
  var domEl = findDOMNode(this);
  return {
    width: domEl.offsetWidth + 'px',
    height: domEl.offsetHeight + 'px'
  };
} // This could probably be generalised in inferno-animation as part of animateOnAdd


function animateCrossFadeIn(component, currSize, animationName, callback) {
  var domEl = findDOMNode(component);
  var height = domEl.offsetHeight + 'px';
  var width = domEl.offsetWidth + 'px';
  domEl.style.height = currSize.height;
  domEl.style.width = currSize.width;
  domEl.classList.add(animationName + '-enter'); // Trigger reflow

  var tmp = domEl.offsetHeight; // 2. Set an animation listener, code at end

  var done = false;
  var nrofTransitionsLeft;

  var onTransitionEnd = function onTransitionEnd(event) {
    // Make sure it isn't a child that is triggering the event
    if (event && event.target !== domEl) {
      return;
    }

    if (event !== undefined && nrofTransitionsLeft > 0) {
      nrofTransitionsLeft--;
      return;
    }

    if (done) return;
    done = true; // Clear style stuff

    domEl.style.height = domEl.style.width = '';
    domEl.classList.remove('InfernoAnimation-active');
    domEl.classList.remove(animationName + '-enter-active');
    domEl.classList.remove(animationName + '-enter-end'); // 5. Call callback to allow stuff to happen

    callback && callback(domEl);
  };

  domEl.addEventListener("transitionend", onTransitionEnd, false); // 3. Activate transitions

  domEl.classList.add(animationName + '-enter-active'); // The following is needed so we can prevent nested animations from playing slower
  // than parent animation causing a jump (in for example a cross-fade)

  domEl.classList.add('InfernoAnimation-active');
  var cs = window.getComputedStyle(domEl);
  var dur = cs.getPropertyValue('transition-duration').split(',');
  var del = cs.getPropertyValue('transition-delay').split(',');
  var animTimeout = dur.map(function (v, index) {
    return parseFloat(v) + parseFloat(del[index]);
  }).reduce(function (prev, curr) {
    return prev > curr ? prev : curr;
  }, 0);
  nrofTransitionsLeft = dur.length - 1;
  setTimeout(onTransitionEnd, Math.round(animTimeout * 1000) + 50); // Fallback if transitionend fails

  setTimeout(function () {
    domEl.style.height = height;
    domEl.style.width = width;
    domEl.classList.remove(animationName + '-enter');
    domEl.classList.add(animationName + '-enter-end');
  }, 5);
}

var TabContent =
/*#__PURE__*/
function (_Component) {
  _inherits(TabContent, _Component);

  function TabContent(props) {
    var _this;

    _classCallCheck(this, TabContent);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TabContent).call(this, props));
    _this.state = {
      activeTab: _this.props.activeTab
    };
    return _this;
  }

  _createClass(TabContent, [{
    key: "getChildContext",
    value: function getChildContext() {
      return {
        activeTabId: this.state
      };
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.state.activeTab !== nextProps.activeTab) {
        var sourceSize = getContentSize.call(this);
        this.setState({
          activeTab: nextProps.activeTab
        });

        if (nextProps.fade) {
          requestAnimationFrame(function () {
            animateCrossFadeIn(_this2, sourceSize, 'FadeIn');
          });
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          children = _this$props.children,
          className = _this$props.className,
          cssModule = _this$props.cssModule,
          Tag = _this$props.tag;
      var attributes = omit(this.props, omitProps$1);
      var classes = mapToCssModules(classNames('tab-content', className), cssModule);
      Object.assign(attributes, {
        className: classes
      });
      return infernoCreateElement.createElement(Tag, attributes, children);
    }
  }]);

  return TabContent;
}(inferno.Component);
TabContent.defaultProps = defaultProps$U;

var defaultProps$V = {
  tag: 'div'
};
function TabPane(props, context) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      tabId = props.tabId,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tabId", "tag"]);

  var classes = mapToCssModules(classNames('tab-pane', className, {
    active: tabId === context.activeTabId.activeTab
  }), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
}
TabPane.defaultProps = defaultProps$V;

var defaultProps$W = {
  tag: 'div'
};

var Jumbotron = function Jumbotron(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      fluid = props.fluid,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag", "fluid"]);

  var classes = mapToCssModules(classNames(className, 'jumbotron', fluid ? 'jumbotron-fluid' : false), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

Jumbotron.defaultProps = defaultProps$W;

var defaultProps$X = {
  color: 'success',
  tag: 'div'
};

var Alert = function Alert(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      color = props.color,
      onClose = props.onClose,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag", "color", "onClose"]);

  var classes = mapToCssModules(classNames(className, 'alert', "alert-".concat(color), {
    'alert-dismissible': onClose
  }), cssModule);
  var closeClasses = mapToCssModules('close', cssModule);
  Object.assign(attributes, {
    className: classes,
    role: 'alert'
  });
  var childEls = [onClose ? inferno.createVNode(1, "button", closeClasses, inferno.createVNode(1, "span", null, "\xD7", 16, {
    "aria-hidden": "true"
  }), 2, {
    "type": "button",
    "aria-label": "Close",
    "onClick": onClose
  }) : null, children];
  return infernoCreateElement.createElement(Tag, attributes, childEls);
};

Alert.defaultProps = defaultProps$X;

var addClassName$1 = infernoAnimation.utils.addClassName,
    removeClassName$1 = infernoAnimation.utils.removeClassName,
    registerTransitionListener$1 = infernoAnimation.utils.registerTransitionListener,
    forceReflow$1 = infernoAnimation.utils.forceReflow,
    clearDimensions = infernoAnimation.utils.clearDimensions,
    getDimensions = infernoAnimation.utils.getDimensions,
    setDimensions = infernoAnimation.utils.setDimensions,
    setDisplay$1 = infernoAnimation.utils.setDisplay;
/**
 * These are the open and close animation helpers
 */

function _animateCollapseOnRemove(node, animCls, callback) {
  var clone = node.cloneNode(true);

  var _getDimensions = getDimensions(node),
      width = _getDimensions.width,
      height = _getDimensions.height;

  setDimensions(clone, width, height);
  addClassName$1(clone, 'collapse show');
  setDisplay$1(node, 'none !important');
  node.parentNode.appendChild(clone);
  addClassName$1(clone, 'collapsing');
  registerTransitionListener$1(clone, function () {
    // *** Cleanup ***
    callback && callback(clone);
    clone.remove();
  });
  setTimeout(function () {
    removeClassName$1(clone, 'collapse show');
    clearDimensions(clone);
  }, 5);
}

function _animateCollapseOnAdd(node, animCls, callback) {
  var _getDimensions2 = getDimensions(node),
      width = _getDimensions2.width,
      height = _getDimensions2.height;

  addClassName$1(node, 'collapse');
  forceReflow$1();
  addClassName$1(node, 'collapsing');
  setDisplay$1(node, 'block');
  registerTransitionListener$1([node, node.children[0]], function () {
    // *** Cleanup ***
    removeClassName$1(node, 'collapsing');
    clearDimensions(node);
    callback && callback(node);
  }); //setTimeout(() => {

  setDimensions(node, width, height);
  addClassName$1(node, 'collapse show');
  removeClassName$1(node, 'collapse'); //}, 5) 
}

function Animated$1(props) {
  var Tag = props.tag,
      children = props.children,
      attrs = _objectWithoutProperties(props, ["tag", "children"]);

  return infernoCreateElement.createElement(Tag || 'div', attrs, children);
}
/**
 * This is the bootstrap code:
 */


var defaultProps$Y = {
  isOpen: false,
  tag: 'div',
  onOpened: function onOpened() {},
  onClosed: function onClosed() {}
};

var Collapse =
/*#__PURE__*/
function (_Component) {
  _inherits(Collapse, _Component);

  function Collapse(props) {
    var _this;

    _classCallCheck(this, Collapse);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Collapse).call(this, props));
    _this.state = {
      active: false
    };
    return _this;
  }

  _createClass(Collapse, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setState({
        active: true
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _omit = omit(this.props, ['isOpen', 'delay', 'onOpened', 'onClosed']),
          className = _omit.className,
          cssModule = _omit.cssModule,
          Tag = _omit.tag,
          attributes = _objectWithoutProperties(_omit, ["className", "cssModule", "tag"]);

      var classes = mapToCssModules(classNames(className, !this.state.active && 'InfernoAnimation-noAnim'), cssModule);
      var prefix = this.props.animationClassNames; // If hidden

      if (!this.props.isOpen) return null;
      return inferno.normalizeProps(inferno.createComponentVNode(2, Animated$1, _objectSpread({}, attributes, {
        "tag": Tag,
        "className": classes
      }), null, {
        "onComponentDidMount": function onComponentDidMount(dom) {
          return _animateCollapseOnAdd(dom, _this2.props.onOpened);
        },
        "onComponentWillUnmount": function onComponentWillUnmount(dom) {
          return _animateCollapseOnRemove(dom, _this2.props.onClosed);
        }
      }));
    }
  }]);

  return Collapse;
}(inferno.Component);

Collapse.defaultProps = defaultProps$Y;

var defaultProps$Z = {
  tag: 'ul'
};

var ListGroup = function ListGroup(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      Tag = props.tag,
      flush = props.flush,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag", "flush"]);

  var classes = mapToCssModules(classNames(className, 'list-group', flush ? 'list-group-flush' : false), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

ListGroup.defaultProps = defaultProps$Z;

var defaultProps$_ = {
  tag: 'li'
};

var handleDisabledOnClick = function handleDisabledOnClick(e) {
  e.preventDefault();
};

var ListGroupItem = function ListGroupItem(props) {
  var children = props.children,
      className = props.className,
      Tag = props.tag,
      active = props.active,
      disabled = props.disabled,
      action = props.action,
      color = props.color,
      attributes = _objectWithoutProperties(props, ["children", "className", "tag", "active", "disabled", "action", "color"]);

  var classes = mapToCssModules(classNames(className, active ? 'active' : false, disabled ? 'disabled' : false, action ? 'list-group-item-action' : false, color ? "list-group-item-".concat(color) : false, 'list-group-item')); // Prevent click event when disabled.

  if (disabled) {
    attributes.onClick = handleDisabledOnClick;
  }

  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

ListGroupItem.defaultProps = defaultProps$_;

var defaultProps$10 = {
  tag: 'h5'
};

var ListGroupItemHeading = function ListGroupItemHeading(props) {
  var children = props.children,
      className = props.className,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "tag"]);

  var classes = mapToCssModules(classNames(className, 'list-group-item-heading'));
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

ListGroupItemHeading.defaultProps = defaultProps$10;

var defaultProps$11 = {
  tag: 'p'
};

var ListGroupItemText = function ListGroupItemText(props) {
  var children = props.children,
      className = props.className,
      Tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "tag"]);

  var classes = mapToCssModules(classNames(className, 'list-group-item-text'));
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

ListGroupItemText.defaultProps = defaultProps$11;

var Media = function Media(props) {
  var vertical = props.vertical,
      children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      href = props.href,
      tag = props.tag,
      attributes = _objectWithoutProperties(props, ["vertical", "children", "className", "cssModule", "href", "tag"]);

  var Tag = href !== undefined ? tag || 'a' : tag || 'div';
  var classes = mapToCssModules(classNames(className, {
    'media': true,
    'flex-column': vertical
  }), cssModule);
  Object.assign(attributes, {
    className: classes,
    href: href
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

var MediaBody = function MediaBody(props) {
  var children = props.children,
      className = props.className,
      cssModule = props.cssModule,
      tag = props.tag,
      attributes = _objectWithoutProperties(props, ["children", "className", "cssModule", "tag"]);

  var Tag = tag || 'div';
  var classes = mapToCssModules(classNames(className, 'media-body'), cssModule);
  Object.assign(attributes, {
    className: classes
  });
  return infernoCreateElement.createElement(Tag, attributes, children);
};

var Image = function Image(props) {
  var baseline = props.baseline,
      top = props.top,
      middle = props.middle,
      bottom = props.bottom,
      textTop = props.textTop,
      textBottom = props.textBottom,
      href = props.href,
      target = props.target,
      responsive = props.responsive,
      spacing = props.spacing,
      className = props.className,
      cssModule = props.cssModule,
      attributes = _objectWithoutProperties(props, ["baseline", "top", "middle", "bottom", "textTop", "textBottom", "href", "target", "responsive", "spacing", "className", "cssModule"]);

  var alignment = {
    'align-baseline': baseline,
    'align-self-start': top,
    'align-self-end': bottom,
    'align-self-center': middle,
    'align-text-top': textTop,
    'align-text-bottom': textBottom
  };
  var responsiveWrapperClasses = responsive && 'embed-responsive embed-responsive-' + responsive;
  var responsiveItemClasses = responsive && 'embed-responsive-item';

  if (href) {
    var classes = mapToCssModules(classNames(className, responsiveItemClasses), cssModule);
    var anchorClasses = mapToCssModules(classNames(alignment, responsiveWrapperClasses, spacing), cssModule);
    var anchorAttributes = {
      href: href,
      target: target
    };
    return inferno.normalizeProps(inferno.createVNode(1, "a", anchorClasses, inferno.normalizeProps(inferno.createVNode(1, "img", classes, null, 1, _objectSpread({}, attributes))), 2, _objectSpread({}, anchorAttributes)));
  } else if (responsive) {
    var _classes = mapToCssModules(classNames(className, responsiveItemClasses), cssModule);

    var wrapperClasses = mapToCssModules(classNames(alignment, responsiveWrapperClasses, spacing), cssModule);
    return inferno.createVNode(1, "div", wrapperClasses, inferno.normalizeProps(inferno.createVNode(1, "img", _classes, null, 1, _objectSpread({}, attributes))), 2);
  } else {
    var _classes2 = mapToCssModules(classNames(className, alignment, spacing), cssModule);

    return inferno.normalizeProps(inferno.createVNode(1, "img", _classes2, null, 1, _objectSpread({}, attributes)));
  }
};

var defaultProps$12 = {
  type: 'border',
  children: 'Loading...'
};

var Spinner = function Spinner(props) {
  var className = props.className,
      cssModule = props.cssModule,
      type = props.type,
      size = props.size,
      color = props.color,
      children = props.children,
      attributes = _objectWithoutProperties(props, ["className", "cssModule", "type", "size", "color", "children"]);

  var classes = mapToCssModules(classNames(className, size ? "spinner-".concat(type, "-").concat(size) : false, "spinner-".concat(type), color ? "text-".concat(color) : false), cssModule);
  return inferno.normalizeProps(inferno.createVNode(1, "div", classes, children && inferno.createVNode(1, "span", mapToCssModules('sr-only', cssModule), children, 0), 0, _objectSpread({
    "role": "status"
  }, attributes)));
};

Spinner.defaultProps = defaultProps$12;

exports.Alert = Alert;
exports.Container = Container;
exports.Row = Row;
exports.Col = Col;
exports.Navbar = Navbar;
exports.NavbarBrand = NavbarBrand;
exports.NavbarToggler = NavbarToggler;
exports.Nav = Nav;
exports.NavItem = NavItem;
exports.NavDropdown = NavDropdown;
exports.NavLink = NavLink;
exports.Breadcrumb = Breadcrumb;
exports.BreadcrumbItem = BreadcrumbItem;
exports.Button = Button;
exports.ButtonDropdown = ButtonDropdown;
exports.ButtonGroup = ButtonGroup;
exports.ButtonToolbar = ButtonToolbar;
exports.Dropdown = Dropdown;
exports.DropdownItem = DropdownItem;
exports.DropdownMenu = DropdownMenu;
exports.DropdownToggle = DropdownToggle;
exports.Badge = Badge;
exports.Card = Card;
exports.CardLink = CardLink;
exports.CardGroup = CardGroup;
exports.CardDeck = CardDeck;
exports.CardColumns = CardColumns;
exports.CardBody = CardBody;
exports.CardFooter = CardFooter;
exports.CardHeader = CardHeader;
exports.CardImg = CardImg;
exports.CardImgOverlay = CardImgOverlay;
exports.CardSubtitle = CardSubtitle;
exports.CardText = CardText;
exports.CardTitle = CardTitle;
exports.Popover = Popover;
exports.PopoverBody = PopoverBody;
exports.PopoverHeader = PopoverHeader;
exports.PopperContent = PopperContent;
exports.PopperTargetHelper = PopperTargetHelper;
exports.Progress = Progress;
exports.Modal = Modal;
exports.ModalHeader = ModalHeader;
exports.ModalBody = ModalBody;
exports.ModalFooter = ModalFooter;
exports.Table = Table;
exports.Form = Form;
exports.FormFeedback = FormFeedback;
exports.FormGroup = FormGroup;
exports.FormText = FormText;
exports.Input = Input;
exports.InputGroup = InputGroup;
exports.InputGroupAddon = InputGroupAddon;
exports.InputGroupButton = InputGroupButton;
exports.InputGroupButtonDropdown = InputGroupButtonDropdown;
exports.InputGroupText = InputGroupText;
exports.Label = Label;
exports.Pagination = Pagination;
exports.PaginationItem = PaginationItem;
exports.PaginationLink = PaginationLink;
exports.TabContent = TabContent;
exports.TabPane = TabPane;
exports.Jumbotron = Jumbotron;
exports.Collapse = Collapse;
exports.ListGroup = ListGroup;
exports.ListGroupItem = ListGroupItem;
exports.ListGroupItemText = ListGroupItemText;
exports.ListGroupItemHeading = ListGroupItemHeading;
exports.Spinner = Spinner;
exports.Media = Media;
exports.MediaBody = MediaBody;
exports.Image = Image;
exports.Util = utils;
//# sourceMappingURL=index.js.map
