import _objectSpread from "@babel/runtime/helpers/objectSpread";
import _typeof from "@babel/runtime/helpers/typeof";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import { createVNode, createComponentVNode, normalizeProps } from "inferno";
import { Component } from 'inferno';
import classNames from 'classnames';
import PopperContent from './PopperContent';
import { getTarget, mapToCssModules, omit } from './utils';
var propsToOmit = ['placement', 'target', 'container', 'isOpen', 'disabled', 'hideArrow', 'className', 'innerClassName', 'cssModule', 'toggle', 'autohide', 'placementPrefix', 'delay', 'modifiers'];
var DEFAULT_DELAYS = {
  show: 0,
  hide: 250
};
var defaultProps = {
  isOpen: false,
  hideArrow: false,
  placement: 'top',
  placementPrefix: 'bs-tooltip',
  delay: DEFAULT_DELAYS,
  autohide: true,
  toggle: function toggle() {}
};

var Tooltip =
/*#__PURE__*/
function (_Component) {
  _inherits(Tooltip, _Component);

  function Tooltip(props) {
    var _this;

    _classCallCheck(this, Tooltip);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tooltip).call(this, props));
    _this.addTargetEvents = _this.addTargetEvents.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.removeTargetEvents = _this.removeTargetEvents.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.toggle = _this.toggle.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onMouseOverTooltip = _this.onMouseOverTooltip.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onMouseLeaveTooltip = _this.onMouseLeaveTooltip.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onMouseOverTooltipContent = _this.onMouseOverTooltipContent.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onMouseLeaveTooltipContent = _this.onMouseLeaveTooltipContent.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.show = _this.show.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.hide = _this.hide.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(Tooltip, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._target = getTarget(this.props.target);
      this.addTargetEvents();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeTargetEvents();
    }
  }, {
    key: "onMouseOverTooltip",
    value: function onMouseOverTooltip() {
      if (this._hideTimeout) {
        this.clearHideTimeout();
      }

      this._showTimeout = setTimeout(this.show, this.getDelay('show'));
    }
  }, {
    key: "onMouseLeaveTooltip",
    value: function onMouseLeaveTooltip() {
      if (this._showTimeout) {
        this.clearShowTimeout();
      }

      this._hideTimeout = setTimeout(this.hide, this.getDelay('hide'));
    }
  }, {
    key: "onMouseOverTooltipContent",
    value: function onMouseOverTooltipContent() {
      if (this.props.autohide) {
        return;
      }

      if (this._hideTimeout) {
        this.clearHideTimeout();
      }
    }
  }, {
    key: "onMouseLeaveTooltipContent",
    value: function onMouseLeaveTooltipContent() {
      if (this.props.autohide) {
        return;
      }

      if (this._showTimeout) {
        this.clearShowTimeout();
      }

      this._hideTimeout = setTimeout(this.hide, this.getDelay('hide'));
    }
  }, {
    key: "getDelay",
    value: function getDelay(key) {
      var delay = this.props.delay;

      if (_typeof(delay) === 'object') {
        return isNaN(delay[key]) ? DEFAULT_DELAYS[key] : delay[key];
      }

      return delay;
    }
  }, {
    key: "show",
    value: function show() {
      if (!this.props.isOpen) {
        this.clearShowTimeout();
        this.toggle();
      }
    }
  }, {
    key: "hide",
    value: function hide() {
      if (this.props.isOpen) {
        this.clearHideTimeout();
        this.toggle();
      }
    }
  }, {
    key: "clearShowTimeout",
    value: function clearShowTimeout() {
      clearTimeout(this._showTimeout);
      this._showTimeout = undefined;
    }
  }, {
    key: "clearHideTimeout",
    value: function clearHideTimeout() {
      clearTimeout(this._hideTimeout);
      this._hideTimeout = undefined;
    }
  }, {
    key: "handleDocumentClick",
    value: function handleDocumentClick(e) {
      if (e.target === this._target || this._target.contains(e.target)) {
        if (this._hideTimeout) {
          this.clearHideTimeout();
        }

        if (!this.props.isOpen) {
          this.toggle();
        }
      }
    }
  }, {
    key: "addTargetEvents",
    value: function addTargetEvents() {
      var _this2 = this;

      this._target.addEventListener('mouseover', this.onMouseOverTooltip, true);

      this._target.addEventListener('mouseout', this.onMouseLeaveTooltip, true);

      ['click', 'touchstart'].forEach(function (event) {
        return document.addEventListener(event, _this2.handleDocumentClick, true);
      });
    }
  }, {
    key: "removeTargetEvents",
    value: function removeTargetEvents() {
      var _this3 = this;

      this._target.removeEventListener('mouseover', this.onMouseOverTooltip, true);

      this._target.removeEventListener('mouseout', this.onMouseLeaveTooltip, true);

      ['click', 'touchstart'].forEach(function (event) {
        return document.removeEventListener(event, _this3.handleDocumentClick, true);
      });
    }
  }, {
    key: "toggle",
    value: function toggle(e) {
      if (this.props.disabled) {
        return e && e.preventDefault();
      }

      return this.props.toggle();
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.props.isOpen) {
        return null;
      }

      var attributes = omit(this.props, propsToOmit);
      var classes = mapToCssModules(classNames('tooltip-inner', this.props.innerClassName), this.props.cssModule);
      var popperClasses = mapToCssModules(classNames('tooltip', 'show', this.props.className), this.props.cssModule);
      return createComponentVNode(2, PopperContent, {
        "className": popperClasses,
        "target": this.props.target,
        "isOpen": this.props.isOpen,
        "hideArrow": this.props.hideArrow,
        "placement": this.props.placement,
        "placementPrefix": this.props.placementPrefix,
        "container": this.props.container,
        "modifiers": this.props.modifiers,
        children: normalizeProps(createVNode(1, "div", classes, null, 1, _objectSpread({}, attributes, {
          "onMouseOver": this.onMouseOverTooltipContent,
          "onMouseLeave": this.onMouseLeaveTooltipContent
        })))
      });
    }
  }]);

  return Tooltip;
}(Component);

Tooltip.defaultProps = defaultProps;
export default Tooltip;