{"ast":null,"code":"import hoistNonReactStatics from 'hoist-non-inferno-statics';\nimport { normalizeProps, createComponentVNode, Component } from 'inferno';\nimport { bindActionCreators } from 'redux';\nvar CLEARED = null; // tslint:disable-next-line:no-empty\n\nvar nullSubscriptionHandler = function nullSubscriptionHandler() {};\n\nvar nullListenerCollection = {\n  // tslint:disable-next-line:no-empty\n  clear: function clear() {},\n  // tslint:disable-next-line:no-empty\n  notify: function notify() {},\n  subscribe: function subscribe(_) {\n    return nullSubscriptionHandler;\n  }\n};\n\nvar createListenerCollection = function createListenerCollection() {\n  // the current/next pattern is copied from redux's createStore code.\n  var current = [];\n  var next = [];\n  return {\n    clear: function clear() {\n      next = CLEARED;\n      current = CLEARED;\n    },\n    notify: function notify() {\n      var listeners = current = next;\n\n      for (var i = 0; i < listeners.length; ++i) {\n        listeners[i]();\n      }\n    },\n    subscribe: function subscribe(listener) {\n      var isSubscribed = true;\n\n      if (next === current) {\n        next = current.slice();\n      }\n\n      next.push(listener);\n      return function () {\n        if (!isSubscribed || current === null) {\n          return;\n        }\n\n        isSubscribed = false;\n\n        if (next === current) {\n          next = current.slice();\n        }\n\n        next.splice(next.indexOf(listener), 1);\n      };\n    }\n  };\n};\n\nvar Subscription = function Subscription(store, parentSub, onStateChange) {\n  this.store = store;\n  this.parentSub = parentSub;\n  this.onStateChange = onStateChange;\n  this.unsubscribe = null;\n  this.listeners = nullListenerCollection;\n};\n\nSubscription.prototype.addNestedSub = function addNestedSub(listener) {\n  this.trySubscribe();\n  return this.listeners.subscribe(listener);\n};\n\nSubscription.prototype.notifyNestedSubs = function notifyNestedSubs() {\n  this.listeners.notify();\n};\n\nSubscription.prototype.isSubscribed = function isSubscribed() {\n  return Boolean(this.unsubscribe);\n};\n\nSubscription.prototype.trySubscribe = function trySubscribe() {\n  if (!this.unsubscribe) {\n    this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);\n    this.listeners = createListenerCollection();\n  }\n};\n\nSubscription.prototype.tryUnsubscribe = function tryUnsubscribe() {\n  if (this.unsubscribe) {\n    this.unsubscribe();\n    this.unsubscribe = null;\n    this.listeners.clear();\n    this.listeners = nullListenerCollection;\n  }\n};\n\nfunction combineFrom(first, second) {\n  var out = {};\n\n  if (first) {\n    for (var key in first) {\n      out[key] = first[key];\n    }\n  }\n\n  if (second) {\n    for (var key$1 in second) {\n      out[key$1] = second[key$1];\n    }\n  }\n\n  return out;\n}\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nvar hotReloadingVersion = 0;\nvar dummyState = {}; // tslint:disable-next-line:no-empty\n\nvar noop = function noop() {};\n\nvar makeSelectorStateful = function makeSelectorStateful(sourceSelector, store) {\n  // wrap the selector in an object that tracks its results between runs.\n  var selector = {\n    error: null,\n    props: {},\n    run: function runComponentSelector(props) {\n      try {\n        var nextProps = sourceSelector(store.getState(), props);\n\n        if (nextProps !== selector.props || selector.error) {\n          selector.shouldComponentUpdate = true;\n          selector.props = nextProps;\n          selector.error = null;\n        }\n      } catch (e) {\n        selector.shouldComponentUpdate = true;\n        selector.error = e;\n      }\n    },\n    shouldComponentUpdate: false\n  };\n  return selector;\n}; // TODO: Move\n\n\nvar invariant = function invariant(test, error) {\n  if (!test) {\n    throw new Error(error);\n  }\n};\n\nfunction getDefaultName(name) {\n  return \"ConnectAdvanced(\" + name + \")\";\n}\n\nfunction connectAdvanced(selectorFactory, ref) {\n  var getDisplayName = ref.getDisplayName;\n  if (getDisplayName === void 0) getDisplayName = getDefaultName;\n  var methodName = ref.methodName;\n  if (methodName === void 0) methodName = 'connectAdvanced';\n  var renderCountProp = ref.renderCountProp;\n  if (renderCountProp === void 0) renderCountProp = null;\n  var shouldHandleStateChanges = ref.shouldHandleStateChanges;\n  if (shouldHandleStateChanges === void 0) shouldHandleStateChanges = true;\n  var storeKey = ref.storeKey;\n  if (storeKey === void 0) storeKey = 'store';\n  var withRef = ref.withRef;\n  if (withRef === void 0) withRef = false;\n  var rest = objectWithoutProperties(ref, [\"getDisplayName\", \"methodName\", \"renderCountProp\", \"shouldHandleStateChanges\", \"storeKey\", \"withRef\"]);\n  var connectOptions = rest;\n  var subscriptionKey = storeKey + 'Subscription';\n  var version = hotReloadingVersion++;\n\n  var wrapWithConnect = function wrapWithConnect(WrappedComponent) {\n    invariant(typeof WrappedComponent === 'function', \"You must pass a component to the function returned by \" + \"connect. Instead received \" + WrappedComponent);\n    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    var displayName = getDisplayName(wrappedComponentName);\n    var selectorFactoryOptions = combineFrom(connectOptions, {\n      WrappedComponent: WrappedComponent,\n      displayName: displayName,\n      getDisplayName: getDisplayName,\n      methodName: methodName,\n      renderCountProp: renderCountProp,\n      shouldHandleStateChanges: shouldHandleStateChanges,\n      storeKey: storeKey,\n      withRef: withRef,\n      wrappedComponentName: wrappedComponentName\n    });\n\n    var Connect =\n    /*@__PURE__*/\n    function (Component) {\n      function Connect(props, context) {\n        Component.call(this, props, context);\n        this.version = version;\n        this.state = {};\n        this.renderCount = 0;\n        this.store = this.props[storeKey] || this.context[storeKey];\n        this.propsMode = Boolean(props[storeKey]);\n        this.setWrappedInstance = this.setWrappedInstance.bind(this);\n        invariant(!!this.store, \"Could not find \\\"\" + storeKey + \"\\\" in either the context or \" + \"props of \\\"\" + displayName + \"\\\". \" + \"Either wrap the root component in a <Provider>, \" + \"or explicitly pass \\\"\" + storeKey + \"\\\" as a prop to \\\"\" + displayName + \"\\\".\");\n        this.initSelector();\n        this.initSubscription();\n      }\n\n      if (Component) Connect.__proto__ = Component;\n      Connect.prototype = Object.create(Component && Component.prototype);\n      Connect.prototype.constructor = Connect;\n\n      Connect.prototype.getChildContext = function getChildContext() {\n        var obj; // If this component received store from props, its subscription should be transparent\n        // to any descendants receiving store+subscription from context; it passes along\n        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows\n        // Connect to control ordering of notifications to flow top-down.\n\n        var subscription = this.propsMode ? null : this.subscription;\n        return obj = {}, obj[subscriptionKey] = subscription || this.context[subscriptionKey], obj;\n      };\n\n      Connect.prototype.componentWillMount = function componentWillMount() {\n        if (!shouldHandleStateChanges || this.$SSR) {\n          return;\n        }\n\n        this.subscription.trySubscribe();\n        this.selector.run(this.props);\n      };\n\n      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n        this.selector.run(nextProps);\n      };\n\n      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {\n        return this.selector.shouldComponentUpdate;\n      };\n\n      Connect.prototype.componentWillUnmount = function componentWillUnmount() {\n        if (this.subscription) {\n          this.subscription.tryUnsubscribe();\n        } // these are just to guard against extra memory leakage if a parent element doesn't\n        // dereference this instance properly, such as an async callback that never finishes\n\n\n        this.subscription = null;\n        this.notifyNestedSubs = noop;\n        this.store = null;\n        this.selector.run = noop;\n        this.selector.shouldComponentUpdate = false;\n      };\n\n      Connect.prototype.getWrappedInstance = function getWrappedInstance() {\n        invariant(withRef, \"To access the wrapped instance, you need to specify \" + \"{ withRef: true } in the options argument of the \" + methodName + \"() call.\");\n        return this.wrappedInstance;\n      };\n\n      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {\n        this.wrappedInstance = ref;\n      };\n\n      Connect.prototype.initSelector = function initSelector() {\n        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);\n        this.selector = makeSelectorStateful(sourceSelector, this.store);\n        this.selector.run(this.props);\n      };\n\n      Connect.prototype.initSubscription = function initSubscription() {\n        if (!shouldHandleStateChanges) {\n          return;\n        } // parentSub's source should match where store came from: props vs. context. A component\n        // connected to the store via props shouldn't use subscription from context, or vice versa.\n\n\n        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];\n        this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this)); // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in\n        // the middle of the notification loop, where `this.subscription` will then be null. An\n        // extra null check every change can be avoided by copying the method onto `this` and then\n        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's\n        // listeners logic is changed to not call listeners that have been unsubscribed in the\n        // middle of the notification loop.\n\n        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);\n      };\n\n      Connect.prototype.onStateChange = function onStateChange() {\n        this.selector.run(this.props);\n\n        if (!this.selector.shouldComponentUpdate) {\n          this.notifyNestedSubs();\n        } else {\n          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;\n          this.setState(dummyState);\n        }\n      };\n\n      Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {\n        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it\n        // needs to notify nested subs. Once called, it unimplements itself until further state\n        // changes occur. Doing it this way vs having a permanent `componentDidMount` that does\n        // a boolean check every time avoids an extra method call most of the time, resulting\n        // in some perf boost.\n        this.componentDidUpdate = undefined;\n        this.notifyNestedSubs();\n      };\n\n      Connect.prototype.isSubscribed = function isSubscribed() {\n        return Boolean(this.subscription && this.subscription.isSubscribed());\n      };\n\n      Connect.prototype.addExtraProps = function addExtraProps(props) {\n        if (!renderCountProp) {\n          return props;\n        } // make a shallow copy so that fields added don't leak to the original selector.\n        // this is especially important for 'ref' since that's a reference back to the component\n        // instance. a singleton memoized selector would then be holding a reference to the\n        // instance, preventing the instance from being garbage collected, and that would be bad\n\n\n        var withExtras = combineFrom(props, null);\n\n        if (renderCountProp) {\n          withExtras[renderCountProp] = this.renderCount++;\n        }\n\n        if (this.propsMode && this.subscription) {\n          withExtras[subscriptionKey] = this.subscription;\n        }\n\n        return withExtras;\n      };\n\n      Connect.prototype.render = function render() {\n        var selector = this.selector;\n        selector.shouldComponentUpdate = false;\n\n        if (selector.error) {\n          throw selector.error;\n        } else {\n          return normalizeProps(createComponentVNode(2\n          /* ComponentUnknown */\n          , WrappedComponent, this.addExtraProps(selector.props), null, withRef ? this.setWrappedInstance : null));\n        }\n      };\n\n      return Connect;\n    }(Component);\n\n    Connect.displayName = displayName;\n    Connect.WrappedComponent = WrappedComponent;\n    return hoistNonReactStatics(Connect, WrappedComponent);\n  };\n\n  return wrapWithConnect;\n}\n\nvar Provider =\n/*@__PURE__*/\nfunction (Component) {\n  function Provider(props, context) {\n    Component.call(this, props, context);\n    this.store = props.store;\n  }\n\n  if (Component) Provider.__proto__ = Component;\n  Provider.prototype = Object.create(Component && Component.prototype);\n  Provider.prototype.constructor = Provider;\n\n  Provider.prototype.getChildContext = function getChildContext() {\n    return {\n      store: this.store,\n      storeSubscription: null\n    };\n  };\n\n  Provider.prototype.render = function render() {\n    return this.props.children;\n  };\n\n  return Provider;\n}(Component);\n\nProvider.displayName = 'Provider';\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nvar shallowEqual = function shallowEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  var countA = 0;\n  var countB = 0;\n\n  for (var key in a) {\n    if (hasOwn.call(a, key) && a[key] !== b[key]) {\n      return false;\n    }\n\n    countA++;\n  }\n\n  for (var key$1 in b) {\n    if (hasOwn.call(b, key$1)) {\n      countB++;\n    }\n  }\n\n  return countA === countB;\n}; // TODO: Type\n\n\nvar wrapMapToPropsConstant = function wrapMapToPropsConstant(getConstant) {\n  return function (dispatch, options) {\n    var constant = getConstant(dispatch, options);\n\n    var constantSelector = function constantSelector() {\n      return constant;\n    };\n\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n}; // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n\n\nvar getDependsOnOwnProps = function getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? !!mapToProps.dependsOnOwnProps : mapToProps.length !== 1;\n}; // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\n\n\nvar wrapMapToPropsFunc = function wrapMapToPropsFunc(mapToProps, methodName) {\n  return function (_dispatch, ref) {\n    var displayName = ref.displayName;\n\n    var proxy = function proxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);\n    };\n\n    proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n\n    proxy.mapToProps = function (stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      var props = proxy(stateOrDispatch, ownProps);\n\n      if (typeof props === 'function') {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n\n      return props;\n    };\n\n    return proxy;\n  };\n};\n\nvar whenMapDispatchToPropsIsFunction = function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {\n  return typeof mapDispatchToProps === 'function' ? wrapMapToPropsFunc(mapDispatchToProps) : undefined;\n};\n\nvar whenMapDispatchToPropsIsMissing = function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {\n  return !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {\n    return {\n      dispatch: dispatch\n    };\n  }) : undefined;\n};\n\nvar whenMapDispatchToPropsIsObject = function whenMapDispatchToPropsIsObject(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(function (dispatch) {\n    return bindActionCreators(mapDispatchToProps, dispatch);\n  }) : undefined;\n};\n\nvar defaultMapDispatchToPropsFactories = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];\n\nvar whenMapStateToPropsIsFunction = function whenMapStateToPropsIsFunction(mapStateToProps) {\n  return typeof mapStateToProps === 'function' ? wrapMapToPropsFunc(mapStateToProps) : undefined;\n};\n\nvar whenMapStateToPropsIsMissing = function whenMapStateToPropsIsMissing(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(function () {\n    return {};\n  }) : undefined;\n};\n\nvar defaultMapStateToPropsFactories = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];\n\nvar defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  var merged = combineFrom(ownProps, stateProps);\n\n  if (dispatchProps) {\n    for (var key in dispatchProps) {\n      merged[key] = dispatchProps[key];\n    }\n  }\n\n  return merged;\n};\n\nvar wrapMergePropsFunc = function wrapMergePropsFunc(mergeProps) {\n  return function (_dispatch, ref) {\n    var displayName = ref.displayName;\n    var pure = ref.pure;\n    var areMergedPropsEqual = ref.areMergedPropsEqual;\n    var hasRunOnce = false;\n    var mergedProps;\n    return function (stateProps, dispatchProps, ownProps) {\n      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n\n      if (hasRunOnce) {\n        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) {\n          mergedProps = nextMergedProps;\n        }\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n      }\n\n      return mergedProps;\n    };\n  };\n};\n\nvar whenMergePropsIsFunction = function whenMergePropsIsFunction(mergeProps) {\n  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;\n};\n\nvar whenMergePropsIsOmitted = function whenMergePropsIsOmitted(mergeProps) {\n  return !mergeProps ? function () {\n    return defaultMergeProps;\n  } : undefined;\n};\n\nvar defaultMergePropsFactories = [whenMergePropsIsFunction, whenMergePropsIsOmitted];\n\nfunction objectWithoutProperties$1(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nvar impureFinalPropsSelectorFactory = function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {\n  return function (state, ownProps) {\n    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);\n  };\n};\n\nvar pureFinalPropsSelectorFactory = function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, ref) {\n  var areStatesEqual = ref.areStatesEqual;\n  var areOwnPropsEqual = ref.areOwnPropsEqual;\n  var areStatePropsEqual = ref.areStatePropsEqual;\n  var hasRunAtLeastOnce = false;\n  var state;\n  var ownProps;\n  var stateProps;\n  var dispatchProps;\n  var mergedProps;\n\n  var handleFirstCall = function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  };\n\n  var handleNewPropsAndNewState = function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n\n    if (mapDispatchToProps.dependsOnOwnProps) {\n      dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    }\n\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  };\n\n  var handleNewProps = function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) {\n      stateProps = mapStateToProps(state, ownProps);\n    }\n\n    if (mapDispatchToProps.dependsOnOwnProps) {\n      dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    }\n\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  };\n\n  var handleNewState = function handleNewState() {\n    var nextStateProps = mapStateToProps(state, ownProps);\n    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n\n    if (statePropsChanged) {\n      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    }\n\n    return mergedProps;\n  };\n\n  var handleSubsequentCalls = function handleSubsequentCalls(nextState, nextOwnProps) {\n    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    var stateChanged = !areStatesEqual(nextState, state);\n    state = nextState;\n    ownProps = nextOwnProps;\n\n    if (propsChanged && stateChanged) {\n      return handleNewPropsAndNewState();\n    }\n\n    if (propsChanged) {\n      return handleNewProps();\n    }\n\n    if (stateChanged) {\n      return handleNewState();\n    }\n\n    return mergedProps;\n  };\n\n  var pureFinalPropsSelector = function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n\n  return pureFinalPropsSelector;\n}; // If pure is true, the selector returned by selectorFactory will memoize its results,\n// allowing connectAdvanced's shouldComponentUpdate to return false if final\n// props have not changed. If false, the selector will always return a new\n// object and shouldComponentUpdate will always return true.\n\n\nvar defaultSelectorFactory = function defaultSelectorFactory(dispatch, ref) {\n  var initMapStateToProps = ref.initMapStateToProps;\n  var initMapDispatchToProps = ref.initMapDispatchToProps;\n  var initMergeProps = ref.initMergeProps;\n  var rest = objectWithoutProperties$1(ref, [\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"]);\n  var opts = rest;\n  var options = opts; // trick typescript\n\n  var mapStateToProps = initMapStateToProps(dispatch, options);\n  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  var mergeProps = initMergeProps(dispatch, options);\n  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;\n  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n};\n\nfunction objectWithoutProperties$2(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nvar match = function match(arg, factories, name) {\n  for (var i = factories.length - 1; i >= 0; i--) {\n    var result = factories[i](arg);\n\n    if (result) {\n      return result;\n    }\n  }\n\n  return function (_dispatch, options) {\n    throw new Error(\"Invalid value of type \" + typeof arg + \" for \" + name + \" argument when connecting component \" + options.wrappedComponentName + \".\");\n  };\n};\n\nvar strictEqual = function strictEqual(a, b) {\n  return a === b;\n}; // createConnect with default args builds the 'official' connect behavior. Calling it with\n// different options opens up some testing and extensibility scenarios\n\n\nvar createConnect = function createConnect(ref) {\n  if (ref === void 0) ref = {};\n  var connectHOC = ref.connectHOC;\n  if (connectHOC === void 0) connectHOC = connectAdvanced;\n  var mapStateToPropsFactories = ref.mapStateToPropsFactories;\n  if (mapStateToPropsFactories === void 0) mapStateToPropsFactories = defaultMapStateToPropsFactories;\n  var mapDispatchToPropsFactories = ref.mapDispatchToPropsFactories;\n  if (mapDispatchToPropsFactories === void 0) mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories;\n  var mergePropsFactories = ref.mergePropsFactories;\n  if (mergePropsFactories === void 0) mergePropsFactories = defaultMergePropsFactories;\n  var selectorFactory = ref.selectorFactory;\n  if (selectorFactory === void 0) selectorFactory = defaultSelectorFactory;\n  return function (mapStateToProps, mapDispatchToProps, mergeProps, ref) {\n    if (ref === void 0) ref = {};\n    var pure = ref.pure;\n    if (pure === void 0) pure = true;\n    var areStatesEqual = ref.areStatesEqual;\n    if (areStatesEqual === void 0) areStatesEqual = strictEqual;\n    var areOwnPropsEqual = ref.areOwnPropsEqual;\n    if (areOwnPropsEqual === void 0) areOwnPropsEqual = shallowEqual;\n    var areStatePropsEqual = ref.areStatePropsEqual;\n    if (areStatePropsEqual === void 0) areStatePropsEqual = shallowEqual;\n    var areMergedPropsEqual = ref.areMergedPropsEqual;\n    if (areMergedPropsEqual === void 0) areMergedPropsEqual = shallowEqual;\n    var rest = objectWithoutProperties$2(ref, [\"pure\", \"areStatesEqual\", \"areOwnPropsEqual\", \"areStatePropsEqual\", \"areMergedPropsEqual\"]);\n    var extraOptions = rest;\n    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');\n    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');\n    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');\n    return connectHOC(selectorFactory, combineFrom({\n      // used in error messages\n      methodName: 'connect',\n      // used to compute Connect's displayName from the wrapped component's displayName.\n      // tslint:disable-next-line:object-literal-sort-keys\n      getDisplayName: function getDisplayName(name) {\n        return \"Connect(\" + name + \")\";\n      },\n      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes\n      shouldHandleStateChanges: !!mapStateToProps,\n      // passed through to selectorFactory\n      areMergedPropsEqual: areMergedPropsEqual,\n      areOwnPropsEqual: areOwnPropsEqual,\n      areStatePropsEqual: areStatePropsEqual,\n      areStatesEqual: areStatesEqual,\n      initMapDispatchToProps: initMapDispatchToProps,\n      initMapStateToProps: initMapStateToProps,\n      initMergeProps: initMergeProps,\n      pure: pure\n    }, extraOptions\n    /* any extra options args can override defaults of connect or connectAdvanced */\n    ));\n  };\n};\n\nvar connect = createConnect();\n\nfunction wrapActionCreators(actionCreators) {\n  return function (dispatch) {\n    return bindActionCreators(actionCreators, dispatch);\n  };\n}\n\nexport { Provider, connect, connectAdvanced, wrapActionCreators };","map":null,"metadata":{},"sourceType":"module"}