{"ast":null,"code":"import { Component, createComponentVNode, linkEvent, createVNode } from 'inferno';\nimport { parsePath, createPath, createBrowserHistory, createHashHistory, createMemoryHistory, createLocation as createLocation$1, locationsAreEqual } from 'history';\nimport pathToRegexp from 'path-to-regexp-es6';\nimport hoistNonReactStatics from 'hoist-non-inferno-statics';\nvar isArray = Array.isArray;\n\nfunction isInvalid(o) {\n  return o === null || o === false || o === true || o === void 0;\n}\n\nfunction combineFrom(first, second) {\n  var out = {};\n\n  if (first) {\n    for (var key in first) {\n      out[key] = first[key];\n    }\n  }\n\n  if (second) {\n    for (var key$1 in second) {\n      out[key$1] = second[key$1];\n    }\n  }\n\n  return out;\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  if (!condition) {\n    var error;\n\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n\n    throw error;\n  }\n}\n/**\n * The public API for putting history on context.\n */\n\n\nvar Router =\n/*@__PURE__*/\nfunction (Component) {\n  function Router(props, context) {\n    Component.call(this, props, context);\n    this.state = {\n      match: this.computeMatch(props.history.location.pathname)\n    };\n  }\n\n  if (Component) Router.__proto__ = Component;\n  Router.prototype = Object.create(Component && Component.prototype);\n  Router.prototype.constructor = Router;\n\n  Router.prototype.getChildContext = function getChildContext() {\n    var childContext = combineFrom(this.context.router, null);\n    childContext.history = this.props.history;\n    childContext.route = {\n      location: childContext.history.location,\n      match: this.state.match\n    };\n    return {\n      router: childContext\n    };\n  };\n\n  Router.prototype.computeMatch = function computeMatch(pathname) {\n    return {\n      isExact: pathname === '/',\n      params: {},\n      path: '/',\n      url: '/'\n    };\n  };\n\n  Router.prototype.componentWillMount = function componentWillMount() {\n    var this$1 = this;\n    var ref = this.props;\n    var history = ref.history; // Do this here so we can setState when a <Redirect> changes the\n    // location in componentWillMount. This happens e.g. when doing\n    // server rendering using a <StaticRouter>.\n\n    this.unlisten = history.listen(function () {\n      this$1.setState({\n        match: this$1.computeMatch(history.location.pathname)\n      });\n    });\n  };\n\n  Router.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.unlisten();\n  };\n\n  Router.prototype.render = function render(props) {\n    return props.children;\n  };\n\n  return Router;\n}(Component);\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n} // tslint:disable-next-line:no-empty\n\n\nvar noop = function noop() {};\n\nvar StaticRouter =\n/*@__PURE__*/\nfunction (Component) {\n  function StaticRouter() {\n    var this$1 = this;\n    Component.apply(this, arguments);\n\n    this.createHref = function (path) {\n      return addLeadingSlash(this$1.props.basename + createURL(path));\n    };\n\n    this.handlePush = function (location) {\n      var ref = this$1.props;\n      var basename = ref.basename;\n      var context = ref.context;\n      context.action = 'PUSH';\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    };\n\n    this.handleReplace = function (location) {\n      var ref = this$1.props;\n      var basename = ref.basename;\n      var context = ref.context;\n      context.action = 'REPLACE';\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    }; // tslint:disable-next-line:no-empty\n\n\n    this.handleListen = function () {\n      return noop;\n    }; // tslint:disable-next-line:no-empty\n\n\n    this.handleBlock = function () {\n      return noop;\n    };\n  }\n\n  if (Component) StaticRouter.__proto__ = Component;\n  StaticRouter.prototype = Object.create(Component && Component.prototype);\n  StaticRouter.prototype.constructor = StaticRouter;\n\n  StaticRouter.prototype.getChildContext = function getChildContext() {\n    return {\n      router: {\n        staticContext: this.props.context\n      }\n    };\n  };\n\n  StaticRouter.prototype.render = function render(ref) {\n    var basename = ref.basename;\n    var context = ref.context;\n    var location = ref.location;\n    var rest = objectWithoutProperties(ref, [\"basename\", \"context\", \"location\"]);\n    var props = rest;\n    return createComponentVNode(4\n    /* ComponentClass */\n    , Router, combineFrom(props, {\n      history: {\n        action: 'POP',\n        block: this.handleBlock,\n        createHref: this.createHref,\n        go: staticHandler('go'),\n        goBack: staticHandler('goBack'),\n        goForward: staticHandler('goForward'),\n        listen: this.handleListen,\n        location: stripBasename(basename, createLocation(location)),\n        push: this.handlePush,\n        replace: this.handleReplace\n      }\n    }));\n  };\n\n  return StaticRouter;\n}(Component);\n\nStaticRouter.defaultProps = {\n  basename: '',\n  location: '/'\n};\n\nfunction normalizeLocation(ref) {\n  var pathname = ref.pathname;\n  if (pathname === void 0) pathname = '/';\n  var search = ref.search;\n  var hash = ref.hash;\n  return {\n    hash: (hash || '') === '#' ? '' : hash,\n    pathname: pathname,\n    search: (search || '') === '?' ? '' : search\n  };\n}\n\nfunction addBasename(basename, location) {\n  if (!basename) {\n    return location;\n  }\n\n  return combineFrom(location, {\n    pathname: addLeadingSlash(basename) + location.pathname\n  });\n}\n\nfunction stripBasename(basename, location) {\n  if (!basename) {\n    return location;\n  }\n\n  var base = addLeadingSlash(basename);\n\n  if (location.pathname.indexOf(base) !== 0) {\n    return location;\n  }\n\n  return combineFrom(location, {\n    pathname: location.pathname.substr(base.length)\n  });\n}\n\nfunction createLocation(location) {\n  return typeof location === 'string' ? parsePath(location) : normalizeLocation(location);\n}\n\nfunction createURL(location) {\n  return typeof location === 'string' ? location : createPath(location);\n}\n\nfunction staticHandler(methodName) {\n  return function () {\n    invariant(false, 'You cannot %s with <StaticRouter>', methodName);\n  };\n}\n\nvar BrowserRouter =\n/*@__PURE__*/\nfunction (Component) {\n  function BrowserRouter(props, context) {\n    Component.call(this, props, context);\n    this.history = createBrowserHistory(props);\n  }\n\n  if (Component) BrowserRouter.__proto__ = Component;\n  BrowserRouter.prototype = Object.create(Component && Component.prototype);\n  BrowserRouter.prototype.constructor = BrowserRouter;\n\n  BrowserRouter.prototype.render = function render() {\n    return createComponentVNode(4\n    /* ComponentClass */\n    , Router, {\n      children: this.props.children,\n      history: this.history\n    });\n  };\n\n  return BrowserRouter;\n}(Component);\n\nvar HashRouter =\n/*@__PURE__*/\nfunction (Component) {\n  function HashRouter(props, context) {\n    Component.call(this, props, context);\n    this.history = createHashHistory(props);\n  }\n\n  if (Component) HashRouter.__proto__ = Component;\n  HashRouter.prototype = Object.create(Component && Component.prototype);\n  HashRouter.prototype.constructor = HashRouter;\n\n  HashRouter.prototype.render = function render() {\n    return createComponentVNode(4\n    /* ComponentClass */\n    , Router, {\n      children: this.props.children,\n      history: this.history\n    });\n  };\n\n  return HashRouter;\n}(Component);\n\nvar MemoryRouter =\n/*@__PURE__*/\nfunction (Component) {\n  function MemoryRouter(props, context) {\n    Component.call(this, props, context);\n    this.history = createMemoryHistory(props);\n  }\n\n  if (Component) MemoryRouter.__proto__ = Component;\n  MemoryRouter.prototype = Object.create(Component && Component.prototype);\n  MemoryRouter.prototype.constructor = MemoryRouter;\n\n  MemoryRouter.prototype.render = function render() {\n    return createComponentVNode(4\n    /* ComponentClass */\n    , Router, {\n      children: this.props.children,\n      history: this.history\n    });\n  };\n\n  return MemoryRouter;\n}(Component);\n\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nvar compilePath = function compilePath(pattern, options) {\n  var cacheKey = \"\" + options.end + options.strict + options.sensitive;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n\n  if (cache[pattern]) {\n    return cache[pattern];\n  }\n\n  var keys = [];\n  var re = pathToRegexp(pattern, keys, options);\n  var compiledPattern = {\n    re: re,\n    keys: keys\n  };\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern;\n    cacheCount++;\n  }\n\n  return compiledPattern;\n};\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\n\n\nfunction matchPath(pathname, options) {\n  if (typeof options === 'string') {\n    options = {\n      path: options\n    };\n  }\n\n  var path = options.path;\n  if (path === void 0) path = '/';\n  var exact = options.exact;\n  if (exact === void 0) exact = false;\n  var strict = options.strict;\n  if (strict === void 0) strict = false;\n  var sensitive = options.sensitive;\n  if (sensitive === void 0) sensitive = false;\n  var ref = compilePath(path, {\n    end: exact,\n    strict: strict,\n    sensitive: sensitive\n  });\n  var re = ref.re;\n  var keys = ref.keys;\n  var match = re.exec(pathname);\n\n  if (!match) {\n    return null;\n  }\n\n  var url = match[0];\n  var values = match.slice(1);\n  var isExact = pathname === url;\n\n  if (exact && !isExact) {\n    return null;\n  }\n\n  return {\n    isExact: isExact,\n    params: keys.reduce(function (memo, key, index) {\n      memo[key.name] = values[index];\n      return memo;\n    }, {}),\n    path: path,\n    url: path === '/' && url === '' ? '/' : url // the matched portion of the URL\n\n  };\n}\n/**\n * The public API for matching a single path and rendering.\n */\n\n\nvar Route =\n/*@__PURE__*/\nfunction (Component) {\n  function Route(props, context) {\n    Component.call(this, props, context);\n    this.state = {\n      match: this.computeMatch(props, context.router)\n    };\n  }\n\n  if (Component) Route.__proto__ = Component;\n  Route.prototype = Object.create(Component && Component.prototype);\n  Route.prototype.constructor = Route;\n\n  Route.prototype.getChildContext = function getChildContext() {\n    var childContext = combineFrom(this.context.router, null);\n    childContext.route = {\n      location: this.props.location || this.context.router.route.location,\n      match: this.state.match\n    };\n    return {\n      router: childContext\n    };\n  };\n\n  Route.prototype.computeMatch = function computeMatch(ref, router) {\n    var computedMatch = ref.computedMatch;\n    var location = ref.location;\n    var path = ref.path;\n    var strict = ref.strict;\n    var exact = ref.exact;\n    var sensitive = ref.sensitive;\n\n    if (computedMatch) {\n      // <Switch> already computed the match for us\n      return computedMatch;\n    }\n\n    var route = router.route;\n    var pathname = (location || route.location).pathname;\n    return path ? matchPath(pathname, {\n      path: path,\n      strict: strict,\n      exact: exact,\n      sensitive: sensitive\n    }) : route.match;\n  };\n\n  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {\n    this.setState({\n      match: this.computeMatch(nextProps, nextContext.router)\n    });\n  };\n\n  Route.prototype.render = function render() {\n    var ref = this.state;\n    var match = ref.match;\n    var ref$1 = this.props;\n    var children = ref$1.children;\n    var component = ref$1.component;\n    var render = ref$1.render;\n    var ref$2 = this.context.router;\n    var history = ref$2.history;\n    var route = ref$2.route;\n    var staticContext = ref$2.staticContext;\n    var location = this.props.location || route.location;\n    var props = {\n      match: match,\n      location: location,\n      history: history,\n      staticContext: staticContext\n    };\n\n    if (component) {\n      return match ? createComponentVNode(2\n      /* ComponentUnknown */\n      , component, props) : null;\n    }\n\n    if (render) {\n      return match ? render(props, this.context) : null;\n    }\n\n    if (typeof children === 'function') {\n      return children(props);\n    }\n\n    return children;\n  };\n\n  return Route;\n}(Component);\n\nfunction getMatch(ref, route, location) {\n  var path = ref.path;\n  var exact = ref.exact;\n  var strict = ref.strict;\n  var sensitive = ref.sensitive;\n  var from = ref.from;\n  var pathProp = path || from;\n  return pathProp ? matchPath(location.pathname, {\n    path: pathProp,\n    exact: exact,\n    strict: strict,\n    sensitive: sensitive\n  }) : route.match;\n}\n\nfunction extractMatchFromChildren(children, route, location) {\n  var match;\n\n  var _child;\n\n  if (isArray(children)) {\n    for (var i = 0; i < children.length; ++i) {\n      _child = children[i];\n\n      if (isArray(_child)) {\n        var nestedMatch = extractMatchFromChildren(_child, route, location);\n        match = nestedMatch.match;\n        _child = nestedMatch._child;\n      } else {\n        match = getMatch(_child.props, route, location);\n      }\n\n      if (match) {\n        break;\n      }\n    }\n  } else {\n    match = getMatch(children.props, route, location);\n    _child = children;\n  }\n\n  return {\n    match: match,\n    _child: _child\n  };\n}\n\nvar Switch =\n/*@__PURE__*/\nfunction (Component) {\n  function Switch() {\n    Component.apply(this, arguments);\n  }\n\n  if (Component) Switch.__proto__ = Component;\n  Switch.prototype = Object.create(Component && Component.prototype);\n  Switch.prototype.constructor = Switch;\n\n  Switch.prototype.render = function render() {\n    var ref = this.context.router;\n    var route = ref.route;\n    var ref$1 = this.props;\n    var children = ref$1.children;\n    var location = this.props.location || route.location;\n\n    if (isInvalid(children)) {\n      return null;\n    }\n\n    var ref$2 = extractMatchFromChildren(children, route, location);\n    var match = ref$2.match;\n    var _child = ref$2._child;\n\n    if (match) {\n      return createComponentVNode(_child.flags, _child.type, combineFrom(_child.props, {\n        location: location,\n        computedMatch: match\n      }));\n    }\n\n    return null;\n  };\n\n  return Switch;\n}(Component);\n\nfunction objectWithoutProperties$1(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nvar isModifiedEvent = function isModifiedEvent(event) {\n  return Boolean(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n};\n\nfunction handleClick(ref, event) {\n  var props = ref.props;\n  var context = ref.context;\n\n  if (props.onClick) {\n    props.onClick(event);\n  }\n\n  if (!event.defaultPrevented && // onClick prevented default\n  event.button === 0 && // ignore everything but left clicks\n  !props.target && // let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event) // ignore clicks with modifier keys\n  ) {\n      event.preventDefault();\n      var ref$1 = context.router;\n      var history = ref$1.history;\n      var replace = props.replace;\n      if (replace === void 0) replace = false;\n      var to = props.to;\n\n      if (replace) {\n        history.replace(to);\n      } else {\n        history.push(to);\n      }\n    }\n}\n/**\n * The public API for rendering a history-aware <a>.\n */\n\n\nfunction Link(props, context) {\n  var replace = props.replace;\n  var children = props.children;\n  var className = props.className;\n  var to = props.to;\n  if (to === void 0) to = '';\n  var innerRef = props.innerRef;\n  var rest$1 = objectWithoutProperties$1(props, [\"replace\", \"children\", \"className\", \"to\", \"innerRef\"]);\n  var rest = rest$1;\n  invariant(context.router, 'You should not use <Link> outside a <Router>');\n  var href = context.router.history.createHref(typeof to === 'string' ? {\n    pathname: to\n  } : to);\n  var newProps = combineFrom(rest, null);\n  newProps.href = href;\n  newProps.onClick = linkEvent({\n    context: context,\n    props: props\n  }, handleClick);\n  return createVNode(1\n  /* HtmlElement */\n  , 'a', className, children, 0\n  /* UnknownChildren */\n  , newProps, null, innerRef);\n}\n\nfunction objectWithoutProperties$2(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nfunction filter(i) {\n  return i;\n}\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\n\n\nfunction NavLink(ref) {\n  var to = ref.to;\n  var exact = ref.exact;\n  var strict = ref.strict;\n  var onClick = ref.onClick;\n  var linkLocation = ref.location;\n  var activeClassName = ref.activeClassName;\n  if (activeClassName === void 0) activeClassName = 'active';\n  var className = ref.className;\n  var activeStyle = ref.activeStyle;\n  var style = ref.style;\n  var getIsActive = ref.isActive;\n  var ariaCurrent = ref.ariaCurrent;\n  if (ariaCurrent === void 0) ariaCurrent = 'true';\n  var rest$1 = objectWithoutProperties$2(ref, [\"to\", \"exact\", \"strict\", \"onClick\", \"location\", \"activeClassName\", \"className\", \"activeStyle\", \"style\", \"isActive\", \"ariaCurrent\"]);\n  var rest = rest$1;\n\n  function linkComponent(ref) {\n    var location = ref.location;\n    var match = ref.match;\n    var isActive = !!(getIsActive ? getIsActive(match, location) : match);\n    return createComponentVNode(8\n    /* ComponentFunction */\n    , Link, combineFrom({\n      'aria-current': isActive && ariaCurrent,\n      className: isActive ? [className, activeClassName].filter(filter).join(' ') : className,\n      onClick: onClick,\n      style: isActive ? combineFrom(style, activeStyle) : style,\n      to: to\n    }, rest));\n  }\n\n  return createComponentVNode(4\n  /* ComponentClass */\n  , Route, {\n    children: linkComponent,\n    exact: exact,\n    location: linkLocation,\n    path: typeof to === 'object' ? to.pathname : to,\n    strict: strict\n  });\n}\n/**\n * The public API for matching a single path and rendering.\n */\n\n\nvar Prompt =\n/*@__PURE__*/\nfunction (Component) {\n  function Prompt() {\n    Component.apply(this, arguments);\n  }\n\n  if (Component) Prompt.__proto__ = Component;\n  Prompt.prototype = Object.create(Component && Component.prototype);\n  Prompt.prototype.constructor = Prompt;\n\n  Prompt.prototype.enable = function enable(message) {\n    if (this.unblock) {\n      this.unblock();\n    }\n\n    this.unblock = this.context.router.history.block(message);\n  };\n\n  Prompt.prototype.disable = function disable() {\n    if (this.unblock) {\n      this.unblock();\n      this.unblock = null;\n    }\n  };\n\n  Prompt.prototype.componentWillMount = function componentWillMount() {\n    invariant(this.context.router, 'You should not use <Prompt> outside a <Router>');\n\n    if (this.props.when) {\n      this.enable(this.props.message);\n    }\n  };\n\n  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (nextProps.when) {\n      if (!this.props.when || this.props.message !== nextProps.message) {\n        this.enable(nextProps.message);\n      }\n    } else {\n      this.disable();\n    }\n  };\n\n  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.disable();\n  };\n\n  Prompt.prototype.render = function render() {\n    return null;\n  };\n\n  return Prompt;\n}(Component);\n\nvar Redirect =\n/*@__PURE__*/\nfunction (Component) {\n  function Redirect() {\n    Component.apply(this, arguments);\n  }\n\n  if (Component) Redirect.__proto__ = Component;\n  Redirect.prototype = Object.create(Component && Component.prototype);\n  Redirect.prototype.constructor = Redirect;\n\n  Redirect.prototype.isStatic = function isStatic() {\n    return this.context.router && this.context.router.staticContext;\n  };\n\n  Redirect.prototype.componentWillMount = function componentWillMount() {\n    invariant(this.context.router, 'You should not use <Redirect> outside a <Router>');\n\n    if (this.isStatic()) {\n      this.perform();\n    }\n  };\n\n  Redirect.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isStatic()) {\n      this.perform();\n    }\n  };\n\n  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var prevTo = createLocation$1(prevProps.to);\n    var nextTo = createLocation$1(this.props.to);\n\n    if (locationsAreEqual(prevTo, nextTo)) {\n      // tslint:disable-next-line:no-console\n      console.error(\"You tried to redirect to the same route you're currently on: \\\"\" + nextTo.pathname + nextTo.search + \"\\\"\");\n      return;\n    }\n\n    this.perform();\n  };\n\n  Redirect.prototype.perform = function perform() {\n    var ref = this.context.router;\n    var history = ref.history;\n    var ref$1 = this.props;\n    var push = ref$1.push;\n    if (push === void 0) push = false;\n    var to = ref$1.to;\n\n    if (push) {\n      history.push(to);\n    } else {\n      history.replace(to);\n    }\n  };\n\n  Redirect.prototype.render = function render() {\n    return null;\n  };\n\n  return Redirect;\n}(Component);\n\nfunction objectWithoutProperties$3(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n/**\n * A public higher-order component to access the imperative API\n */\n\n\nfunction withRouter(Com) {\n  var C = function C(props) {\n    var wrappedComponentRef = props.wrappedComponentRef;\n    var rest = objectWithoutProperties$3(props, [\"wrappedComponentRef\"]);\n    var remainingProps = rest;\n    return createComponentVNode(4\n    /* ComponentClass */\n    , Route, {\n      render: function render(routeComponentProps) {\n        return createComponentVNode(2\n        /* ComponentUnknown */\n        , Com, combineFrom(remainingProps, routeComponentProps), null, wrappedComponentRef);\n      }\n    });\n  };\n\n  C.displayName = \"withRouter(\" + (Com.displayName || Com.name) + \")\";\n  C.WrappedComponent = Com;\n  return hoistNonReactStatics(C, Com);\n}\n\nexport { BrowserRouter, HashRouter, Link, MemoryRouter, NavLink, Prompt, Redirect, Route, Router, StaticRouter, Switch, matchPath, withRouter };","map":null,"metadata":{},"sourceType":"module"}