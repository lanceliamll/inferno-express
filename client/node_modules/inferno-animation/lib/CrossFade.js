import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import { createVNode } from "inferno";
import { Component } from 'inferno';
import { createElement } from 'inferno-create-element';
import { findDOMNode } from 'inferno-extras';
import { animateOnAdd, animateOnRemove } from './animatedComponent';
import { animationIsRunningOnParent, registerTransitionListener, forceReflow, clearDimensions, getDimensions, setDimensions } from './utils';

var animateSizeChange = function animateSizeChange(node, animationName, sourceSize, targetSize) {
  if (animationIsRunningOnParent(node)) return; // 1. Set dimensions

  setDimensions(node, sourceSize.width, sourceSize.height); // node.style.height = sourceSize.height + 'px'
  // node.style.width = sourceSize.width + 'px'

  forceReflow(node); // 2. Set an animation listener, code at end

  registerTransitionListener(node, function () {
    // *** Cleanup ***
    // callback && callback(clone)
    clearDimensions(node);
    node.classList.remove(animationName + '-cross-fade-active');
  }); // 3. Activate transition

  node.classList.add(animationName + '-cross-fade-active'); // 4. Activate target state

  setTimeout(function () {
    setDimensions(node, targetSize.width, targetSize.height);
  }, 5);
};

function _getSizeOfCrossFadeDOMNode(DOMNode) {
  var domEl = DOMNode.parentNode;
  domEl.classList.add('InfernoAnimation--getSize');
  forceReflow(domEl);
  var outpDimensions = getDimensions(domEl);
  domEl.classList.remove('InfernoAnimation--getSize');
  return outpDimensions;
}

var CrossFade =
/*#__PURE__*/
function (_Component) {
  _inherits(CrossFade, _Component);

  function CrossFade(props) {
    var _this;

    _classCallCheck(this, CrossFade);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CrossFade).call(this, props));
    _this.state = {
      active: false
    };
    _this.setTargetSize = _this.setTargetSize.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.setSourceSize = _this.setSourceSize.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._animationCheck = _this._animationCheck.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(CrossFade, [{
    key: "_animationCheck",
    value: function _animationCheck() {
      if (this.state.active && this.targetSize && this.sourceSize && findDOMNode(this)) {
        animateSizeChange(findDOMNode(this), this.props.prefix, this.sourceSize, this.targetSize);
        this.targetSize = this.sourceSize = undefined;
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      setTimeout(function () {
        _this2.targetSize = _this2.sourceSize = undefined;

        _this2.setState({
          active: true
        });
      }, 10);
    }
  }, {
    key: "setTargetSize",
    value: function setTargetSize(DOMNode) {
      this.targetSize = _getSizeOfCrossFadeDOMNode(DOMNode);

      this._animationCheck();
    }
  }, {
    key: "setSourceSize",
    value: function setSourceSize(DOMNode) {
      this.sourceSize = _getSizeOfCrossFadeDOMNode(DOMNode);

      this._animationCheck();
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var elProps = {};

      if (this.props.className) {
        // Using 'InfernoAnimation--noAnim' to block animations in children
        elProps['className'] = this.props.className + (!this.state.active ? ' InfernoAnimation--noAnim' : '');
      } else if (!this.state.active) {
        elProps['className'] = 'InfernoAnimation--noAnim';
      }

      var children = !Array.isArray(this.props.children) ? [this.props.children] : this.props.children;
      var childEls = children.map(function (childEl) {
        return createElement(CrossFadeItem, {
          // onComponentDidMount: this.setTargetSize, onComponentWillUnmount: this.setSourceSize, key: childEl.key
          onEnter: _this3.setTargetSize,
          onLeave: _this3.setSourceSize,
          key: childEl && childEl.key,
          prefix: _this3.props.prefix
        }, childEl);
      });
      return createElement(this.props.el || this.props.tag || 'div', elProps, childEls);
    }
  }]);

  return CrossFade;
}(Component);
/*
function CrossFadeItem (props) {
  return (
    <div className="CrossFadeItem">
      {props.children}
    </div>
  )
}
*/


var CrossFadeItem =
/*#__PURE__*/
function (_Component2) {
  _inherits(CrossFadeItem, _Component2);

  function CrossFadeItem() {
    _classCallCheck(this, CrossFadeItem);

    return _possibleConstructorReturn(this, _getPrototypeOf(CrossFadeItem).apply(this, arguments));
  }

  _createClass(CrossFadeItem, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this4 = this;

      var node = findDOMNode(this);
      this.props.onEnter(node);
      setTimeout(function () {
        return animateOnAdd(node, _this4.props.prefix);
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this5 = this;

      var node = findDOMNode(this);
      this.props.onLeave(node);
      setTimeout(function () {
        return animateOnRemove(node, _this5.props.prefix);
      });
    }
  }, {
    key: "render",
    value: function render() {
      return createVNode(1, "div", "CrossFadeItem", this.props.children, 0);
    }
  }]);

  return CrossFadeItem;
}(Component);

export default CrossFade;