(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('inferno'), require('inferno-create-element')) :
  typeof define === 'function' && define.amd ? define(['exports', 'inferno', 'inferno-create-element'], factory) :
  (factory((global.InfernoAnimation = {}),global.Inferno,global.infernoCreateElement));
}(this, (function (exports,inferno,infernoCreateElement) { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function addClassName(node, className) {
    if (className) {
      var tmp = className.split(' ');

      for (var i = 0; i < tmp.length; i++) {
        node.classList.add(tmp[i]);
      }
    }
  }
  function removeClassName(node, className) {
    if (className) {
      var tmp = className.split(' ');

      for (var i = 0; i < tmp.length; i++) {
        node.classList.remove(tmp[i]);
      }
    }
  }
  function forceReflow() {
    var dummy = document.body.clientHeight;
  }
  function setDisplay(node, value) {
    var oldVal = node.style.display;

    if (oldVal !== value) {
      node.style.display = value;
    }

    return oldVal;
  }

  function _cleanStyle(node) {
    if (!node.style) {
      node.removeAttribute('style');
    }
  }

  function getDimensions(node) {
    var tmpDisplay = node.style.display;
    var isDisplayNone = window.getComputedStyle(node).getPropertyValue('display') === 'none';

    if (isDisplayNone) {
      node.style.display = 'block';
    }

    var tmp = node.getBoundingClientRect();

    if (isDisplayNone) {
      node.style.display = tmpDisplay;

      _cleanStyle(node);
    }

    return {
      width: tmp.width,
      height: tmp.height
    };
  }
  function setDimensions(node, width, height) {
    node.style.width = width + 'px';
    node.style.height = height + 'px';
  }
  function clearDimensions(node) {
    node.style.width = node.style.height = '';
  }
  function animationIsRunningOnParent(node) {
    return node.closest && node.closest('.InfernoAnimation--noAnim');
  }

  function _getMaxTransitionDuration()
  /* add nodes as args*/
  {
    var _arguments = arguments;
    var nrofTransitions = 0;
    var maxDuration = 0;

    var _loop = function _loop(i) {
      var node = _arguments[i];
      if (!node) return "continue";
      var cs = window.getComputedStyle(node);
      var dur = cs.getPropertyValue('transition-duration').split(',');
      var del = cs.getPropertyValue('transition-delay').split(',');
      var props = cs.getPropertyValue('transition-property').split(',').map(function (prop) {
        return prop.trim();
      });
      props.forEach(function (prop) {
        if (prop[0] === '-') {
          var tmp = prop.split('-').splice(2).join('-');

          if (props.indexOf(tmp) >= 0) {
            nrofTransitions--;
          }
        }
      });
      var animTimeout = dur.map(function (v, index) {
        return parseFloat(v) + parseFloat(del[index]);
      }).reduce(function (prev, curr) {
        return prev > curr ? prev : curr;
      }, 0);
      nrofTransitions += dur.length;

      if (animTimeout > maxDuration) {
        maxDuration = animTimeout;
      }
    };

    for (var i = 0; i < arguments.length; i++) {
      var _ret = _loop(i);

      if (_ret === "continue") continue;
    }

    return {
      nrofTransitions: nrofTransitions,
      maxDuration: maxDuration
    };
  }

  function registerTransitionListener(nodes, callback) {
    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }

    var rootNode = nodes[0];
    rootNode.classList.add('InfernoAnimation-active');
    /**
     * Here comes the transition event listener
     */

    var _getMaxTransitionDura = _getMaxTransitionDuration.apply(this, nodes),
        nrofTransitionsLeft = _getMaxTransitionDura.nrofTransitions,
        maxDuration = _getMaxTransitionDura.maxDuration;

    var done = false;

    function onTransitionEnd(event) {
      // Make sure it isn't a child that is triggering the event
      if (event) {
        var goAhead = false;

        for (var i = 0; i < nodes.length; i++) {
          if (event.target === nodes[i]) {
            goAhead = true;
            break;
          }
        }

        if (!goAhead) return;
      }

      if (done || event !== undefined && --nrofTransitionsLeft > 0) {
        return;
      }

      done = true;
      rootNode.classList.remove('InfernoAnimation-active');
      /**
       * Perform cleanup
       */

      rootNode.removeEventListener("transitionend", onTransitionEnd, false);
      callback && callback();
    }

    rootNode.addEventListener("transitionend", onTransitionEnd, false); // Fallback if transitionend fails

    !window.debugAnimations && setTimeout(onTransitionEnd, Math.round(maxDuration * 1000) + 100);
  }

  var animateOnRemove = function animateOnRemove(node, animationName, callback) {
    if (animationIsRunningOnParent(node)) return;
    var animCls = {};

    if (_typeof(animationName) === 'object') {
      animCls = animationName;
    } else {
      animCls['start'] = animationName + '-leave';
      animCls['active'] = animationName + '-leave-active';
      animCls['end'] = animationName + '-leave-end';
    } // 1. Clone DOM node, inject it and hide original


    var clone = node.cloneNode(true);

    var _getDimensions = getDimensions(node),
        width = _getDimensions.width,
        height = _getDimensions.height;

    setDimensions(clone, width, height);
    addClassName(clone, animCls.start); // Leaving original element so it can be removed in the normal way

    setDisplay(node, 'none !important');
    node.insertAdjacentElement('beforebegin', clone); // 2. Set an animation listener, code at end

    registerTransitionListener(clone, function () {
      // *** Cleanup ***
      callback && callback(clone);
      clone.remove();
    }); // 3. Activate transitions

    addClassName(clone, animCls.active); // 4. Activate target state

    setTimeout(function () {
      addClassName(clone, animCls.end);
      removeClassName(clone, animCls.start);
      clearDimensions(clone);
    }, 5);
  };
  var animateOnAdd = function animateOnAdd(node, animationName, callback) {
    if (animationIsRunningOnParent(node)) return;
    var animCls = {};

    if (_typeof(animationName) === 'object') {
      animCls = animationName;
    } else {
      animCls['start'] = animationName + '-enter';
      animCls['active'] = animationName + '-enter-active';
      animCls['end'] = animationName + '-enter-end';
    } // 1. Get height and set start of animation


    var _getDimensions2 = getDimensions(node),
        width = _getDimensions2.width,
        height = _getDimensions2.height;

    addClassName(node, animCls.start);
    forceReflow(); // 2. Set an animation listener, code at end

    registerTransitionListener([node, node.children[0]], function () {
      // *** Cleanup ***
      // 5. Remove the element
      clearDimensions(node);
      removeClassName(node, animCls.active);
      removeClassName(node, animCls.end); // 6. Call callback to allow stuff to happen

      callback && callback(node);
    }); // 3. Activate transition

    addClassName(node, animCls.active); // 4. Activate target state

    setTimeout(function () {
      setDimensions(node, width, height);
      removeClassName(node, animCls.start);
      addClassName(node, animCls.end);
    }, 5);
  };

  function OriginalAnimated(_ref) {
    var el = _ref.el,
        tag = _ref.tag,
        children = _ref.children,
        attrs = _objectWithoutProperties(_ref, ["el", "tag", "children"]);

    return infernoCreateElement.createElement(tag || el || 'div', attrs, children);
  }

  function Animated(_ref2) {
    var prefix = _ref2.prefix,
        onDidEnter = _ref2.onDidEnter,
        onDidLeave = _ref2.onDidLeave,
        attrs = _objectWithoutProperties(_ref2, ["prefix", "onDidEnter", "onDidLeave"]);

    return inferno.normalizeProps(inferno.createComponentVNode(2, OriginalAnimated, _objectSpread({}, attrs), null, {
      "onComponentDidMount": function onComponentDidMount(dom) {
        return animateOnAdd(dom, prefix, onDidEnter);
      },
      "onComponentWillUnmount": function onComponentWillUnmount(dom) {
        return animateOnRemove(dom, prefix, onDidLeave);
      }
    }));
  }
  /*

  // Why did this not work?

  'use strict'
  import { Component } from 'inferno'
  import { createElement } from 'inferno-create-element'
  import { animateOnAdd, animateOnRemove } from './animatedComponent'

  function Animated ({ el, tag, prefix, onDidEnter, onDidLeave, children, ...attrs}) {

    attrs.onComponentDidMount = (dom) => animateOnAdd(dom, prefix, onDidEnter)
    attrs.onComponentWillUnmount = (dom) => animateOnRemove(dom, prefix, onDidLeave)

    return createElement(
      tag || el || 'div', 
      attrs, 
      children
    )
  }

  export default Animated

  */

  function findDOMNode(ref) {
    if (ref && ref.nodeType) {
      return ref;
    }

    if (!ref || ref.$UN) {
      return null;
    }

    if (ref.$LI) {
      return inferno.findDOMfromVNode(ref.$LI, true);
    }

    if (ref.flags) {
      return inferno.findDOMfromVNode(ref, true);
    }

    return null;
  }

  var animateSizeChange = function animateSizeChange(node, animationName, sourceSize, targetSize) {
    if (animationIsRunningOnParent(node)) return; // 1. Set dimensions

    setDimensions(node, sourceSize.width, sourceSize.height); // node.style.height = sourceSize.height + 'px'
    // node.style.width = sourceSize.width + 'px'

    forceReflow(node); // 2. Set an animation listener, code at end

    registerTransitionListener(node, function () {
      // *** Cleanup ***
      // callback && callback(clone)
      clearDimensions(node);
      node.classList.remove(animationName + '-cross-fade-active');
    }); // 3. Activate transition

    node.classList.add(animationName + '-cross-fade-active'); // 4. Activate target state

    setTimeout(function () {
      setDimensions(node, targetSize.width, targetSize.height);
    }, 5);
  };

  function _getSizeOfCrossFadeDOMNode(DOMNode) {
    var domEl = DOMNode.parentNode;
    domEl.classList.add('InfernoAnimation--getSize');
    forceReflow(domEl);
    var outpDimensions = getDimensions(domEl);
    domEl.classList.remove('InfernoAnimation--getSize');
    return outpDimensions;
  }

  var CrossFade =
  /*#__PURE__*/
  function (_Component) {
    _inherits(CrossFade, _Component);

    function CrossFade(props) {
      var _this;

      _classCallCheck(this, CrossFade);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(CrossFade).call(this, props));
      _this.state = {
        active: false
      };
      _this.setTargetSize = _this.setTargetSize.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.setSourceSize = _this.setSourceSize.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this._animationCheck = _this._animationCheck.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }

    _createClass(CrossFade, [{
      key: "_animationCheck",
      value: function _animationCheck() {
        if (this.state.active && this.targetSize && this.sourceSize && findDOMNode(this)) {
          animateSizeChange(findDOMNode(this), this.props.prefix, this.sourceSize, this.targetSize);
          this.targetSize = this.sourceSize = undefined;
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        setTimeout(function () {
          _this2.targetSize = _this2.sourceSize = undefined;

          _this2.setState({
            active: true
          });
        }, 10);
      }
    }, {
      key: "setTargetSize",
      value: function setTargetSize(DOMNode) {
        this.targetSize = _getSizeOfCrossFadeDOMNode(DOMNode);

        this._animationCheck();
      }
    }, {
      key: "setSourceSize",
      value: function setSourceSize(DOMNode) {
        this.sourceSize = _getSizeOfCrossFadeDOMNode(DOMNode);

        this._animationCheck();
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var elProps = {};

        if (this.props.className) {
          // Using 'InfernoAnimation--noAnim' to block animations in children
          elProps['className'] = this.props.className + (!this.state.active ? ' InfernoAnimation--noAnim' : '');
        } else if (!this.state.active) {
          elProps['className'] = 'InfernoAnimation--noAnim';
        }

        var children = !Array.isArray(this.props.children) ? [this.props.children] : this.props.children;
        var childEls = children.map(function (childEl) {
          return infernoCreateElement.createElement(CrossFadeItem, {
            // onComponentDidMount: this.setTargetSize, onComponentWillUnmount: this.setSourceSize, key: childEl.key
            onEnter: _this3.setTargetSize,
            onLeave: _this3.setSourceSize,
            key: childEl && childEl.key,
            prefix: _this3.props.prefix
          }, childEl);
        });
        return infernoCreateElement.createElement(this.props.el || this.props.tag || 'div', elProps, childEls);
      }
    }]);

    return CrossFade;
  }(inferno.Component);
  /*
  function CrossFadeItem (props) {
    return (
      <div className="CrossFadeItem">
        {props.children}
      </div>
    )
  }
  */


  var CrossFadeItem =
  /*#__PURE__*/
  function (_Component2) {
    _inherits(CrossFadeItem, _Component2);

    function CrossFadeItem() {
      _classCallCheck(this, CrossFadeItem);

      return _possibleConstructorReturn(this, _getPrototypeOf(CrossFadeItem).apply(this, arguments));
    }

    _createClass(CrossFadeItem, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this4 = this;

        var node = findDOMNode(this);
        this.props.onEnter(node);
        setTimeout(function () {
          return animateOnAdd(node, _this4.props.prefix);
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var _this5 = this;

        var node = findDOMNode(this);
        this.props.onLeave(node);
        setTimeout(function () {
          return animateOnRemove(node, _this5.props.prefix);
        });
      }
    }, {
      key: "render",
      value: function render() {
        return inferno.createVNode(1, "div", "CrossFadeItem", this.props.children, 0);
      }
    }]);

    return CrossFadeItem;
  }(inferno.Component);

  var utils = {
    addClassName: addClassName,
    animationIsRunningOnParent: animationIsRunningOnParent,
    removeClassName: removeClassName,
    registerTransitionListener: registerTransitionListener,
    forceReflow: forceReflow,
    clearDimensions: clearDimensions,
    getDimensions: getDimensions,
    setDimensions: setDimensions,
    setDisplay: setDisplay
  };

  exports.utils = utils;
  exports.Animated = Animated;
  exports.CrossFade = CrossFade;
  exports.animateOnRemove = animateOnRemove;
  exports.animateOnAdd = animateOnAdd;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
